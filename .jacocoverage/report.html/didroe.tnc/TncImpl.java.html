<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TncImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Tnc&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">didroe.tnc</a> &gt; <span class="el_source">TncImpl.java</span></div><h1>TncImpl.java</h1><pre class="source lang-java linenums">/* 
 * See the &quot;LICENSE&quot; file for the full license governing this code. 
 */
package didroe.tnc;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author Did
 */
<span class="fc" id="L13">public class TncImpl {</span>

<span class="fc" id="L15">    private final Logger logger = LoggerFactory.getLogger(TncImpl.class);</span>

    class FunctionEvaluator {

<span class="fc" id="L19">        private int numEvaluations = 0;</span>

        private final TncFunction function;

        private final int maxEvaluations;

<span class="fc" id="L25">        public FunctionEvaluator(TncFunction function, int maxEvaluations) {</span>
<span class="fc" id="L26">            this.function = function;</span>
<span class="fc" id="L27">            this.maxEvaluations = maxEvaluations;</span>
<span class="fc" id="L28">        }</span>

        public double evaluate(double[] x, double[] g) {
<span class="pc bpc" id="L31" title="1 of 2 branches missed.">            if (numEvaluations &gt;= maxEvaluations) {</span>
<span class="nc" id="L32">                throw new MinimizationError(&quot;Maximum number of function evaluations reached&quot;);</span>
            }

<span class="fc" id="L35">            numEvaluations++;</span>
<span class="fc" id="L36">            return function.evaluate(x, g);</span>
        }

        public int getNumEvaluations() {
<span class="fc" id="L40">            return numEvaluations;</span>
        }
    }

    /**
     * A callback function accepting x as input parameter along with the state pointer.
     */
    public interface TncCallback {

        public void tnc_callback(double[] x);
    }

<span class="fc" id="L52">    public static final double DBL_EPSILON = Math.ulp(1.0);</span>

    FunctionEvaluator functionEvaluator;

    /*
     * tnc : minimize a function with variables subject to bounds, using
     *       gradient information.
     *
     * n         : number of variables (must be &gt;= 0)
     * x         : on input, initial estimate ; on output, the solution
     * f         : on output, the function value at the solution
     * g         : on output, the gradient value at the solution
     *             g should be an allocated vector of size n or NULL,
     *             in which case the gradient value is not returned.
     * function  : the function to minimize (see tnc_function)
     * state     : used by function (see tnc_function)
     * low, up   : the bounds
     *             set low[i] to Double.NEGATIVE_INFINITY to remove the lower bound
     *             set up[i] to Double.POSITIVE_INFINITY to remove the upper bound
     *             if low == NULL, the lower bounds are removed.
     *             if up == NULL, the upper bounds are removed.
     * scale     : scaling factors to apply to each variable
     *             if NULL, the factors are up-low for interval bounded variables
     *             and 1+|x] for the others.
     * offset    : constant to substract to each variable
     *             if NULL, the constant are (up+low)/2 for interval bounded
     *             variables and x for the others.
     * messages  : see the tnc_message enum
     * maxCGit   : max. number of hessian*vector evaluation per main iteration
     *             if maxCGit == 0, the direction chosen is -gradient
     *             if maxCGit &lt; 0, maxCGit is set to max(1,min(50,n/2))
     * maxnfeval : max. number of function evaluation
     * eta       : severity of the line search. if &lt; 0 or &gt; 1, set to 0.25
     * stepmx    : maximum step for the line search. may be increased during call
     *             if too small, will be set to 10.0
     * accuracy  : relative precision for finite difference calculations
     *             if &lt;= machine_precision, set to sqrt(machine_precision)
     * fmin      : minimum function value estimate
     * ftol      : precision goal for the value of f in the stoping criterion
     *             if ftol &lt; 0.0, ftol is set to accuracy
     * xtol      : precision goal for the value of x in the stopping criterion
     *             (after applying x scaling factors)
     *             if xtol &lt; 0.0, xtol is set to sqrt(machine_precision)
     * pgtol     : precision goal for the value of the projected gradient in the
     *             stopping criterion (after applying x scaling factors)
     *             if pgtol &lt; 0.0, pgtol is set to 1e-2 * sqrt(accuracy)
     *             setting it to 0.0 is not recommended
     * rescale   : f scaling factor (in log10) used to trigger f value rescaling
     *             if 0, rescale at each iteration
     *             if a big value, never rescale
     *             if &lt; 0, rescale is set to 1.3
     * nfeval    : on output, the number of function evaluations.
     *             ignored if nfeval==NULL.
     *
     * The tnc function returns a code defined in the tnc_rc enum.
     * On output, x, f and g may be very slightly out of sync because of scaling.
     *
     * This routine solves the optimization problem
     *
     *   minimize   f(x)
     *     x
     *   subject to   low &lt;= x &lt;= up
     *
     * where x is a vector of n real variables. The method used is
     * a truncated-newton algorithm (see &quot;newton-type minimization via
     * the lanczos method&quot; by s.g. nash (siam j. numer. anal. 21 (1984),
     * pp. 770-778).  this algorithm finds a local minimum of f(x). It does
     * not assume that the function f is convex (and so cannot guarantee a
     * global solution), but does assume that the function is bounded below.
     * it can solve problems having any number of variables, but it is
     * especially useful when the number of variables (n) is large.    
     */
<span class="fc" id="L124">    int numIterations = 0;</span>

    public CompletionReason tnc(int n, double[] x, double[] g, TncFunction function,
            double[] low, double[] up, double[] scale,
            double[] offset, int maxCGit, int maxnfeval,
            double eta, double stepmx, double accuracy, double fmin,
            double ftol, double xtol, double pgtol, double rescale,
            TncCallback callback, TncRef ref) {
        /* Scaling parameters */
<span class="fc" id="L133">        double[] xscale = new double[n];</span>
<span class="fc" id="L134">        double[] xoffset = new double[n];</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (scale != null) {</span>
<span class="nc" id="L138">                xscale[i] = Math.abs(scale[i]);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                if (xscale[i] == 0.0) {</span>
<span class="nc" id="L140">                    xoffset[i] = low[i] = up[i] = x[i];</span>
                }
<span class="fc bfc" id="L142" title="All 4 branches covered.">            } else if (low[i] != Double.NEGATIVE_INFINITY &amp;&amp; up[i] != Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L143">                xscale[i] = up[i] - low[i];</span>
<span class="fc" id="L144">                xoffset[i] = (up[i] + low[i]) * 0.5;</span>
            } else {
<span class="fc" id="L146">                xscale[i] = 1.0 + Math.abs(x[i]);</span>
<span class="fc" id="L147">                xoffset[i] = x[i];</span>
            }
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (offset != null) {</span>
<span class="nc" id="L150">                xoffset[i] = offset[i];</span>
            }
        }

        /* Default values for parameters */
<span class="fc" id="L155">        double rteps = Math.sqrt(DBL_EPSILON);</span>

<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (stepmx &lt; rteps * 10.0) {</span>
<span class="fc" id="L158">            stepmx = 1.0e1;</span>
        }
<span class="pc bpc" id="L160" title="3 of 4 branches missed.">        if (eta &lt; 0.0 || eta &gt;= 1.0) {</span>
<span class="fc" id="L161">            eta = 0.25;</span>
        }
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (rescale &lt; 0) {</span>
<span class="fc" id="L164">            rescale = 1.3;</span>
        }
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (maxCGit &lt; 0) {          /* maxCGit == 0 is valid */</span>

<span class="fc" id="L168">            maxCGit = n / 2;</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">            if (maxCGit &lt; 1) {</span>
<span class="nc" id="L170">                maxCGit = 1;</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            } else if (maxCGit &gt; 50) {</span>
<span class="nc" id="L172">                maxCGit = 50;</span>
            }
        }
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (maxCGit &gt; n) {</span>
<span class="nc" id="L176">            maxCGit = n;</span>
        }
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (accuracy &lt;= DBL_EPSILON) {</span>
<span class="fc" id="L179">            accuracy = rteps;</span>
        }
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (ftol &lt; 0.0) {</span>
<span class="fc" id="L182">            ftol = accuracy;</span>
        }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (pgtol &lt; 0.0) {</span>
<span class="fc" id="L185">            pgtol = 1e-2 * Math.sqrt(accuracy);</span>
        }
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (xtol &lt; 0.0) {</span>
<span class="fc" id="L188">            xtol = rteps;</span>
        }

        /* Optimisation */
<span class="fc" id="L192">        tnc_minimizeRef tmpMinRef = new tnc_minimizeRef();</span>
<span class="fc" id="L193">        CompletionReason rc = tnc_minimize(n, x, g, function, xscale, xoffset, low, up, maxCGit, </span>
                maxnfeval, eta, stepmx, accuracy, fmin, ftol, xtol, pgtol, rescale, callback, tmpMinRef);
<span class="fc" id="L195">        ref.f = tmpMinRef.f;</span>

<span class="fc" id="L197">        logger.info(rc.getMessage());</span>

<span class="fc" id="L199">        return rc;</span>
    }

    /**
     * Unscale x
     */
    public void unscalex(double[] x, double[] xscale, double xoffset[]) {
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L207">            x[i] = x[i] * xscale[i] + xoffset[i];</span>
        }
<span class="fc" id="L209">    }</span>

    /**
     * Scale x
     */
    public void scalex(double[] x, double[] xscale, double[] xoffset) {
<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (xscale[i] &gt; 0.0) {</span>
<span class="fc" id="L217">                x[i] = (x[i] - xoffset[i]) / xscale[i];</span>
            }
        }
<span class="fc" id="L220">    }</span>

    /**
     * Scale g
     */
    public void scaleg(double[] g, double[] xscale, double fscale) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (int i = 0; i &lt; g.length; i++) {</span>
<span class="fc" id="L227">            g[i] *= xscale[i] * fscale;</span>
        }
<span class="fc" id="L229">    }</span>

    /**
     * Calculate the pivot vector
     */
    public void setConstraints(int n, double[] x, int[] pivot, double[] xscale,
            double[] xoffset, double[] low, double[] up) {
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
            /* tolerances should be better ajusted */
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            if (xscale[i] == 0.0) {</span>
<span class="nc" id="L239">                pivot[i] = 2;</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            } else if (low[i] != Double.NEGATIVE_INFINITY</span>
                    &amp;&amp; (x[i] * xscale[i] + xoffset[i] - low[i]
<span class="fc bfc" id="L242" title="All 2 branches covered.">                    &lt;= DBL_EPSILON * 10.0 * (Math.abs(low[i]) + 1.0))) {</span>
<span class="fc" id="L243">                pivot[i] = -1;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">            } else if (up[i] != Double.POSITIVE_INFINITY</span>
                    &amp;&amp; (x[i] * xscale[i] + xoffset[i] - up[i]
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">                    &gt;= DBL_EPSILON * 10.0 * (Math.abs(up[i]) + 1.0))) {</span>
<span class="nc" id="L247">                pivot[i] = 1;</span>
            } else {
<span class="fc" id="L249">                pivot[i] = 0;</span>
            }
        }
<span class="fc" id="L252">    }</span>

<span class="fc" id="L254">    public class tnc_minimizeRef {</span>

        public double f;
    }

    /**
     * This routine is a bounds-constrained truncated-newton method. the truncated-newton method is
     * preconditioned by a limited-memory quasi-newton method (this preconditioning strategy is
     * developed in this routine) with a further diagonal scaling (see routine diagonalscaling).
     */
    public CompletionReason tnc_minimize(int n, double[] x, double[] gfull,
            TncFunction function, double[] xscale, double[] xoffset,
            double[] low, double[] up,
            int maxCGit, int maxnfeval, double eta, double stepmx,
            double accuracy, double fmin, double ftol, double xtol,
            double pgtol, double rescale, TncCallback callback, tnc_minimizeRef ref) {
<span class="fc" id="L270">        functionEvaluator = new FunctionEvaluator(function, maxnfeval);</span>

<span class="fc" id="L272">        double fscale = 1.0;</span>
<span class="fc" id="L273">        double alpha = 0.0;         /* Default unused value */</span>

        /* Allocate temporary vectors */
<span class="fc" id="L276">        double[] oldg = new double[n];</span>
<span class="fc" id="L277">        double[] g = new double[n];</span>
<span class="fc" id="L278">        double[] temp = new double[n];</span>
<span class="fc" id="L279">        double[] diagb = new double[n];</span>
<span class="fc" id="L280">        double[] pk = new double[n];</span>
<span class="fc" id="L281">        double[] sk = new double[n];</span>
<span class="fc" id="L282">        double[] yk = new double[n];</span>
<span class="fc" id="L283">        double[] sr = new double[n];</span>
<span class="fc" id="L284">        double[] yr = new double[n];</span>
<span class="fc" id="L285">        int[] pivot = new int[n];</span>

        /* Initialize variables */
<span class="fc" id="L288">        double difnew = 0.0;</span>
<span class="fc" id="L289">        double epsred = 0.05;</span>
<span class="fc" id="L290">        boolean upd1 = true;</span>
<span class="fc" id="L291">        int icycle = n - 1;</span>
<span class="fc" id="L292">        boolean newcon = true;</span>

        /* Uneeded initialisations */
<span class="fc" id="L295">        boolean lreset = false;</span>
<span class="fc" id="L296">        double yrsr = 0.0;</span>
<span class="fc" id="L297">        double yksk = 0.0;</span>

        /* Initial function evaluation */
<span class="fc" id="L300">        ref.f = functionEvaluator.evaluate(x, gfull);</span>

        /* Initial scaling */
<span class="fc" id="L303">        scalex(x, xscale, xoffset);</span>
<span class="fc" id="L304">        ref.f *= fscale;</span>

        /* initial pivot calculation */
<span class="fc" id="L307">        setConstraints(n, x, pivot, xscale, xoffset, low, up);</span>

<span class="fc" id="L309">        ArrayMath.copy(gfull, g);</span>
<span class="fc" id="L310">        scaleg(g, xscale, fscale);</span>

        /* Test the lagrange multipliers to see if they are non-negative. */
<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">            if (-pivot[i] * g[i] &lt; 0.0) {</span>
<span class="fc" id="L315">                pivot[i] = 0;</span>
            }
        }

<span class="fc" id="L319">        project(g, pivot);</span>

        /* Set initial values to other parameters */
<span class="fc" id="L322">        double gnorm = ArrayMath.euclidianNorm(g);</span>

<span class="fc" id="L324">        double fLastConstraint = ref.f;       /* Value at last constraint */</span>

<span class="fc" id="L326">        double fLastReset = ref.f;            /* Value at last reset */</span>

<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (logger.isTraceEnabled()) {</span>
<span class="fc" id="L329">            logger.trace(&quot;  NIT   NF   F                       GTG&quot;);</span>
<span class="fc" id="L330">            printCurrentIteration(n, ref.f / fscale, gfull,</span>
<span class="fc" id="L331">                    numIterations, functionEvaluator.getNumEvaluations(), pivot);</span>
        }

        /* Set the diagonal of the approximate hessian to unity. */
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L336">            diagb[i] = 1.0;</span>
        }

        CompletionReason rc;
        /* Start of main iterative loop */
        while (true) {
            /* Local minimum test */
<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (ArrayMath.euclidianNorm(g) &lt;= pgtol * fscale) {</span>
                /* |PG| == 0.0 =&gt; local minimum */
<span class="fc" id="L345">                ArrayMath.copy(gfull, g);</span>
<span class="fc" id="L346">                project(g, pivot);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L348">                    logger.debug(&quot;|pg| = {} -&gt; local minimum&quot;, ArrayMath.euclidianNorm(g) / fscale);</span>
                }
<span class="fc" id="L350">                rc = CompletionReason.TNC_LOCALMINIMUM;</span>
<span class="fc" id="L351">                break;</span>
            }

            /* Rescale function if necessary */
<span class="fc" id="L355">            double newscale = ArrayMath.euclidianNorm(g);</span>
<span class="pc bpc" id="L356" title="1 of 4 branches missed.">            if ((newscale &gt; DBL_EPSILON) &amp;&amp; (Math.abs(Math.log10(newscale)) &gt; rescale)) {</span>
<span class="fc" id="L357">                newscale = 1.0 / newscale;</span>

<span class="fc" id="L359">                ref.f *= newscale;</span>
<span class="fc" id="L360">                fscale *= newscale;</span>
<span class="fc" id="L361">                gnorm *= newscale;</span>
<span class="fc" id="L362">                fLastConstraint *= newscale;</span>
<span class="fc" id="L363">                fLastReset *= newscale;</span>
<span class="fc" id="L364">                difnew *= newscale;</span>

<span class="fc bfc" id="L366" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L367">                    g[i] *= newscale;</span>
                }
<span class="fc bfc" id="L369" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L370">                    diagb[i] = 1.0;</span>
                }

<span class="fc" id="L373">                upd1 = true;</span>
<span class="fc" id="L374">                icycle = n - 1;</span>
<span class="fc" id="L375">                newcon = true;</span>

<span class="fc" id="L377">                logger.debug(&quot;fscale = {}&quot;, fscale);</span>
            }

<span class="fc" id="L380">            ArrayMath.copy(x, temp);</span>
<span class="fc" id="L381">            project(temp, pivot);</span>
<span class="fc" id="L382">            double xnorm = ArrayMath.euclidianNorm(temp);</span>
<span class="fc" id="L383">            int oldnfeval = functionEvaluator.getNumEvaluations();</span>

            /* Compute the new search direction */
<span class="fc" id="L386">            tnc_directionRef tmpDirRef = new tnc_directionRef();</span>
<span class="fc" id="L387">            tmpDirRef.diagb = diagb;</span>
<span class="fc" id="L388">            tmpDirRef.pivot = pivot;</span>
<span class="fc" id="L389">            tmpDirRef.sk = sk;</span>
<span class="fc" id="L390">            tmpDirRef.sr = sr;</span>
<span class="fc" id="L391">            tmpDirRef.x = x;</span>
<span class="fc" id="L392">            tmpDirRef.yk = yk;</span>
<span class="fc" id="L393">            tmpDirRef.yr = yr;</span>
<span class="fc" id="L394">            tmpDirRef.zsol = pk;</span>
<span class="fc" id="L395">            tnc_direction(g, n, maxCGit, maxnfeval, upd1, yksk, yrsr, lreset, xscale,</span>
                    xoffset, fscale, accuracy, gnorm, xnorm, low, up, tmpDirRef);
<span class="fc" id="L397">            diagb = tmpDirRef.diagb;</span>
<span class="fc" id="L398">            pivot = tmpDirRef.pivot;</span>
<span class="fc" id="L399">            sk = tmpDirRef.sk;</span>
<span class="fc" id="L400">            sr = tmpDirRef.sr;</span>
<span class="fc" id="L401">            x = tmpDirRef.x;</span>
<span class="fc" id="L402">            yk = tmpDirRef.yk;</span>
<span class="fc" id="L403">            yr = tmpDirRef.yr;</span>
<span class="fc" id="L404">            pk = tmpDirRef.zsol;</span>

<span class="fc bfc" id="L406" title="All 2 branches covered.">            if (!newcon) {</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                if (!lreset) {</span>
                    /* Compute the accumulated step and its corresponding gradient
                     difference. */
<span class="fc" id="L410">                    ArrayMath.xPlusY(sk, sr);</span>
<span class="fc" id="L411">                    ArrayMath.xPlusY(yk, yr);</span>
<span class="fc" id="L412">                    icycle++;</span>
                } else {
                    /* Initialize the sum of all the changes */
<span class="fc" id="L415">                    ArrayMath.copy(sk, sr);</span>
<span class="fc" id="L416">                    ArrayMath.copy(yk, yr);</span>
<span class="fc" id="L417">                    fLastReset = ref.f;</span>
<span class="fc" id="L418">                    icycle = 1;</span>
                }
            }

<span class="fc" id="L422">            ArrayMath.copy(g, oldg);</span>
<span class="fc" id="L423">            double oldf = ref.f;</span>
<span class="fc" id="L424">            double oldgtp = ArrayMath.dotProduct(pk, g);</span>

            /* Maximum unconstrained step length */
<span class="fc" id="L427">            double ustpmax = stepmx / (ArrayMath.euclidianNorm(pk) + DBL_EPSILON);</span>

            /* Maximum constrained step length */
<span class="fc" id="L430">            double spe = stepMax(ustpmax, n, x, pk, pivot, low, up, xscale, xoffset);</span>

<span class="fc bfc" id="L432" title="All 2 branches covered.">            if (spe &gt; 0.0) {</span>
                /* Set the initial step length */
<span class="fc" id="L434">                alpha = initialStep(ref.f, fmin / fscale, oldgtp, spe);</span>

                /* Perform the linear search */
<span class="fc" id="L437">                LinearSearchResult lsResult = linearSearch(low, up, xscale, xoffset, fscale, pivot,</span>
                        eta, ftol, spe, pk, x, ref.f, alpha, gfull);
<span class="fc" id="L439">                alpha = lsResult.alpha();</span>
<span class="fc" id="L440">                ref.f = lsResult.f();</span>
<span class="fc" id="L441">                ArrayMath.copy(lsResult.g(), gfull);</span>
<span class="fc" id="L442">                ArrayMath.copy(lsResult.x(), x);</span>


                /* If we went up to the maximum unconstrained step, increase it */
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">                if (alpha &gt;= 0.9 * ustpmax) {</span>
<span class="nc" id="L447">                    stepmx *= 1e2;</span>
<span class="nc" id="L448">                    logger.debug(&quot;stepmx = {}&quot;, stepmx);</span>
                }

                /* If we went up to the maximum constrained step,
                 a new constraint was encountered */
<span class="fc bfc" id="L453" title="All 2 branches covered.">                if (alpha - spe &gt;= -DBL_EPSILON * 10.0) {</span>
<span class="fc" id="L454">                    newcon = true;</span>
                } else {
<span class="fc" id="L456">                    newcon = false;</span>
                }
<span class="fc" id="L458">            } else {</span>
                /* Maximum constrained step == 0.0 =&gt; new constraint */
<span class="fc" id="L460">                newcon = true;</span>
            }

<span class="fc bfc" id="L463" title="All 2 branches covered.">            if (newcon) {</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">                if (!addConstraint(n, x, pk, pivot, low, up, xscale, xoffset)) {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                    if (functionEvaluator.getNumEvaluations() == oldnfeval) {</span>
<span class="nc" id="L466">                        throw new MinimizationError(&quot;Unable to progress&quot;);</span>
                    }
                }
<span class="fc" id="L469">                fLastConstraint = ref.f;</span>
            }

<span class="fc" id="L472">            numIterations++;</span>

            /* Invoke the callback function */
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">            if (callback != null) {</span>
<span class="nc" id="L476">                unscalex(x, xscale, xoffset);</span>
<span class="nc" id="L477">                callback.tnc_callback(x);</span>
<span class="nc" id="L478">                scalex(x, xscale, xoffset);</span>
            }

            /* Set up parameters used in convergence and resetting tests */
<span class="fc" id="L482">            double difold = difnew;</span>
<span class="fc" id="L483">            difnew = oldf - ref.f;</span>

            /* If this is the first iteration of a new cycle, compute the
             percentage reduction factor for the resetting test */
<span class="fc bfc" id="L487" title="All 2 branches covered.">            if (icycle == 1) {</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">                if (difnew &gt; difold * 2.0) {</span>
<span class="fc" id="L489">                    epsred += epsred;</span>
                }
<span class="fc bfc" id="L491" title="All 2 branches covered.">                if (difnew &lt; difold * 0.5) {</span>
<span class="fc" id="L492">                    epsred *= 0.5;</span>
                }
            }

<span class="fc" id="L496">            ArrayMath.copy(gfull, g);</span>
<span class="fc" id="L497">            scaleg(g, xscale, fscale);</span>

<span class="fc" id="L499">            ArrayMath.copy(g, temp);</span>
<span class="fc" id="L500">            project(temp, pivot);</span>
<span class="fc" id="L501">            gnorm = ArrayMath.euclidianNorm(temp);</span>

            /* Reset pivot */
<span class="fc" id="L504">            boolean remcon = removeConstraint(oldgtp, gnorm, pgtol * fscale, ref.f,</span>
                    fLastConstraint, g, pivot, n);

            /* If a constraint is removed */
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">            if (remcon) {</span>
                /* Recalculate gnorm and reset fLastConstraint */
<span class="nc" id="L510">                ArrayMath.copy(g, temp);</span>
<span class="nc" id="L511">                project(temp, pivot);</span>
<span class="nc" id="L512">                gnorm = ArrayMath.euclidianNorm(temp);</span>
<span class="nc" id="L513">                fLastConstraint = ref.f;</span>
            }

<span class="pc bpc" id="L516" title="1 of 4 branches missed.">            if (!remcon &amp;&amp; !newcon) {</span>
                /* No constraint removed &amp; no new constraint : tests for convergence */
<span class="fc bfc" id="L518" title="All 2 branches covered.">                if (Math.abs(difnew) &lt;= ftol * fscale) {</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">                    if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L520">                        logger.debug(&quot;|fn-fn-1] = {} -&gt; convergence&quot;, Math.abs(difnew) / fscale);</span>
                    }
<span class="fc" id="L522">                    rc = CompletionReason.TNC_FCONVERGED;</span>
<span class="fc" id="L523">                    break;</span>
                }
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                if (alpha * ArrayMath.euclidianNorm(pk) &lt;= xtol) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                    if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L527">                        logger.debug(&quot;|xn-xn-1] = %g -&gt; convergence&quot;,</span>
<span class="nc" id="L528">                                alpha * ArrayMath.euclidianNorm(pk));</span>
                    }
<span class="nc" id="L530">                    rc = CompletionReason.TNC_XCONVERGED;</span>
<span class="nc" id="L531">                    break;</span>
                }
            }

<span class="fc" id="L535">            project(g, pivot);</span>

<span class="pc bpc" id="L537" title="1 of 2 branches missed.">            if (logger.isTraceEnabled()) {</span>
<span class="fc" id="L538">                printCurrentIteration(n, ref.f / fscale, gfull,</span>
<span class="fc" id="L539">                        numIterations, functionEvaluator.getNumEvaluations(), pivot);</span>
            }

            /* Compute the change in the iterates and the corresponding change in the
             gradients */
<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (!newcon) {</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L546">                    yk[i] = g[i] - oldg[i];</span>
<span class="fc" id="L547">                    sk[i] = alpha * pk[i];</span>
                }

                /* Set up parameters used in updating the preconditioning strategy */
<span class="fc" id="L551">                yksk = ArrayMath.dotProduct(yk, sk);</span>

<span class="pc bpc" id="L553" title="1 of 4 branches missed.">                if (icycle == (n - 1) || difnew &lt; epsred * (fLastReset - ref.f)) {</span>
<span class="fc" id="L554">                    lreset = true;</span>
                } else {
<span class="fc" id="L556">                    yrsr = ArrayMath.dotProduct(yr, sr);</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">                    if (yrsr &lt;= 0.0) {</span>
<span class="nc" id="L558">                        lreset = true;</span>
                    } else {
<span class="fc" id="L560">                        lreset = false;</span>
                    }
                }
<span class="fc" id="L563">                upd1 = false;</span>
            }
<span class="fc" id="L565">        }</span>

<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (logger.isTraceEnabled()) {</span>
<span class="fc" id="L568">            printCurrentIteration(n, ref.f / fscale, gfull,</span>
<span class="fc" id="L569">                    numIterations, functionEvaluator.getNumEvaluations(), pivot);</span>
        }

        /* Unscaling */
<span class="fc" id="L573">        unscalex(x, xscale, xoffset);</span>
<span class="fc" id="L574">        ArrayMath.clip(x, low, up);</span>
<span class="fc" id="L575">        ref.f /= fscale;</span>

<span class="fc" id="L577">        return rc;</span>
    }

    /**
     * Print the results of the current iteration
     */
    public void printCurrentIteration(int n, double f, double[] g, int niter,
            int nfeval, int[] pivot) {
<span class="fc" id="L585">        double gtg = 0.0;</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">            if (pivot[i] == 0) {</span>
<span class="fc" id="L588">                gtg += g[i] * g[i];</span>
            }
        }

<span class="fc" id="L592">        logger.trace(String.format(&quot; %4d %4d %22.15E  %15.8E&quot;, niter, nfeval, f, gtg));</span>
<span class="fc" id="L593">    }</span>

    /**
     * Set x[i] = 0.0 if direction i is currently constrained
     */
    public void project(double[] x, int[] pivot) {
<span class="fc bfc" id="L599" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">            if (pivot[i] != 0) {</span>
<span class="fc" id="L601">                x[i] = 0.0;</span>
            }
        }
<span class="fc" id="L604">    }</span>

    /**
     * Set x[i] = 0.0 if direction i is constant
     */
    public void projectConstants(int n, double[] x, double[] xscale) {
<span class="fc bfc" id="L610" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">            if (xscale[i] == 0.0) {</span>
<span class="nc" id="L612">                x[i] = 0.0;</span>
            }
        }
<span class="fc" id="L615">    }</span>

    /**
     * Compute the maximum allowable step length
     */
    public double stepMax(double step, int n, double[] x, double[] dir,
            int[] pivot, double[] low, double[] up, double[] xscale, double[] xoffset) {
        /* Constrained maximum step */
<span class="fc bfc" id="L623" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L624" title="1 of 4 branches missed.">            if ((pivot[i] == 0) &amp;&amp; (dir[i] != 0.0)) {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">                if (dir[i] &lt; 0.0) {</span>
<span class="fc" id="L626">                    double t = (low[i] - xoffset[i]) / xscale[i] - x[i];</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">                    if (t &gt; step * dir[i]) {</span>
<span class="fc" id="L628">                        step = t / dir[i];</span>
                    }
<span class="fc" id="L630">                } else {</span>
<span class="fc" id="L631">                    double t = (up[i] - xoffset[i]) / xscale[i] - x[i];</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">                    if (t &lt; step * dir[i]) {</span>
<span class="fc" id="L633">                        step = t / dir[i];</span>
                    }
                }
            }
        }

<span class="fc" id="L639">        return step;</span>
    }

    /**
     * Update the constraint vector pivot if a new constraint is encountered
     */
    public boolean addConstraint(int n, double[] x, double[] p, int[] pivot,
            double[] low, double[] up, double[] xscale, double[] xoffset) {
<span class="fc" id="L647">        boolean newcon = false;</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L649" title="1 of 4 branches missed.">            if ((pivot[i] == 0) &amp;&amp; (p[i] != 0.0)) {</span>
<span class="fc bfc" id="L650" title="All 4 branches covered.">                if (p[i] &lt; 0.0 &amp;&amp; low[i] != Double.NEGATIVE_INFINITY) {</span>
<span class="fc" id="L651">                    double tol = DBL_EPSILON * 10.0 * (Math.abs(low[i]) + 1.0);</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">                    if (x[i] * xscale[i] + xoffset[i] - low[i] &lt;= tol) {</span>
<span class="fc" id="L653">                        pivot[i] = -1;</span>
<span class="fc" id="L654">                        x[i] = (low[i] - xoffset[i]) / xscale[i];</span>
<span class="fc" id="L655">                        newcon = true;</span>
                    }
<span class="fc bfc" id="L657" title="All 2 branches covered.">                } else if (up[i] != Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L658">                    double tol = DBL_EPSILON * 10.0 * (Math.abs(up[i]) + 1.0);</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">                    if (up[i] - (x[i] * xscale[i] + xoffset[i]) &lt;= tol) {</span>
<span class="fc" id="L660">                        pivot[i] = 1;</span>
<span class="fc" id="L661">                        x[i] = (up[i] - xoffset[i]) / xscale[i];</span>
<span class="fc" id="L662">                        newcon = true;</span>
                    }
                }
            }
        }
<span class="fc" id="L667">        return newcon;</span>
    }

    /**
     * Check if a constraint is no more active
     */
    public boolean removeConstraint(double gtpnew, double gnorm, double pgtolfs,
            double f, double fLastConstraint, double[] g, int[] pivot, int n) {
<span class="fc bfc" id="L675" title="All 4 branches covered.">        if (((fLastConstraint - f) &lt;= (gtpnew * -0.5)) &amp;&amp; (gnorm &gt; pgtolfs)) {</span>
<span class="fc" id="L676">            return false;</span>
        }

<span class="fc" id="L679">        int imax = -1;</span>
<span class="fc" id="L680">        double cmax = 0.0;</span>

<span class="fc bfc" id="L682" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">            if (pivot[i] == 2) {</span>
<span class="nc" id="L684">                continue;</span>
            }
<span class="fc" id="L686">            double t = -pivot[i] * g[i];</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">            if (t &lt; cmax) {</span>
<span class="nc" id="L688">                cmax = t;</span>
<span class="nc" id="L689">                imax = i;</span>
            }
        }

<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (imax != -1) {</span>
<span class="nc" id="L694">            pivot[imax] = 0;</span>
<span class="nc" id="L695">            return true;</span>
        } else {
<span class="fc" id="L697">            return false;</span>
        }

        /*
         * For details, see gill, murray, and wright (1981, p. 308) and
         * fletcher (1981, p. 116). The multiplier tests (here, testing
         * the sign of the components of the gradient) may still need to
         * modified to incorporate tolerances for zero.
         */
    }

<span class="fc" id="L708">    public class tnc_directionRef {</span>

        public double[] zsol;
        public double[] diagb;
        public double[] x;
        public double[] sk;
        public double[] yk;
        public double[] sr;
        public double[] yr;
        public int[] pivot;
    }

    /**
     * This routine performs a preconditioned conjugate-gradient iteration in order to solve the
     * newton equations for a search direction for a truncated-newton algorithm. When the value of
     * the quadratic model is sufficiently reduced, the iteration is terminated.
     */
    public void tnc_direction(double[] g, int n, int maxCGit, int maxnfeval,
            boolean upd1, double yksk, double yrsr, boolean lreset,
            double[] xscale, double[] xoffset,
            double fscale, double accuracy, double gnorm, double xnorm,
            double[] low, double[] up, tnc_directionRef ref) {
        /* No CG it. =&gt; dir = -grad */
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (maxCGit == 0) {</span>
<span class="nc" id="L732">            ArrayMath.copy(g, ref.zsol);</span>
<span class="nc" id="L733">            ArrayMath.negate(ref.zsol);</span>
<span class="nc" id="L734">            project(ref.zsol, ref.pivot);</span>
<span class="nc" id="L735">            return;</span>
        }

        /* General initialization */
<span class="fc" id="L739">        double rhsnrm = gnorm;</span>
<span class="fc" id="L740">        double tol = 1e-12;</span>
<span class="fc" id="L741">        double qold = 0.0;</span>
<span class="fc" id="L742">        double rzold = 0.0;                /* Uneeded */</span>

<span class="fc" id="L744">        double[] r = new double[n]; /* Residual */</span>

<span class="fc" id="L746">        double[] v = new double[n];</span>
<span class="fc" id="L747">        double[] zk = new double[n];</span>
<span class="fc" id="L748">        double[] emat = new double[n];   /* Diagonal preconditoning matrix */</span>

<span class="fc" id="L750">        double[] gv = new double[n];       /* hessian times v */</span>

        /* Initialization for preconditioned conjugate-gradient algorithm */
<span class="fc" id="L753">        initPreconditioner(ref.diagb, emat, n, lreset, yksk, yrsr, ref.sk, ref.yk, ref.sr,</span>
                ref.yr, upd1);

<span class="fc bfc" id="L756" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L757">            r[i] = -g[i];</span>
<span class="fc" id="L758">            v[i] = 0.0;</span>
<span class="fc" id="L759">            ref.zsol[i] = 0.0;          /* Computed search direction */</span>

        }

        /* Main iteration */
<span class="fc bfc" id="L764" title="All 2 branches covered.">        for (int k = 0; k &lt; maxCGit; k++) {</span>
            /* CG iteration to solve system of equations */
<span class="fc" id="L766">            project(r, ref.pivot);</span>
<span class="fc" id="L767">            msolve(r, zk, n, ref.sk, ref.yk, ref.diagb, ref.sr, ref.yr, upd1, yksk, yrsr,</span>
                    lreset);
<span class="fc" id="L769">            project(zk, ref.pivot);</span>
<span class="fc" id="L770">            double rz = ArrayMath.dotProduct(r, zk);</span>

<span class="pc bpc" id="L772" title="1 of 2 branches missed.">            if (rz / rhsnrm &lt; tol) {</span>
                /* Truncate algorithm in case of an emergency */
<span class="nc bnc" id="L774" title="All 2 branches missed.">                if (k == 0) {</span>
<span class="nc" id="L775">                    ArrayMath.copy(g, ref.zsol);</span>
<span class="nc" id="L776">                    ArrayMath.negate(ref.zsol);</span>
<span class="nc" id="L777">                    project(ref.zsol, ref.pivot);</span>
                }
                break;
            }
            double beta;
<span class="fc bfc" id="L782" title="All 2 branches covered.">            if (k == 0) {</span>
<span class="fc" id="L783">                beta = 0.0;</span>
            } else {
<span class="fc" id="L785">                beta = rz / rzold;</span>
            }

<span class="fc bfc" id="L788" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L789">                v[i] = zk[i] + beta * v[i];</span>
            }

<span class="fc" id="L792">            project(v, ref.pivot);</span>
<span class="fc" id="L793">            hessianTimesVector(v, gv, n, ref.x, g, xscale, xoffset, fscale,</span>
                    accuracy, xnorm, low, up);
<span class="fc" id="L795">            project(gv, ref.pivot);</span>

<span class="fc" id="L797">            double vgv = ArrayMath.dotProduct(v, gv);</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">            if (vgv / rhsnrm &lt; tol) {</span>
                /* Truncate algorithm in case of an emergency */
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">                if (k == 0) {</span>
<span class="fc" id="L801">                    msolve(g, ref.zsol, n, ref.sk, ref.yk, ref.diagb, ref.sr, ref.yr, upd1, yksk,</span>
                            yrsr, lreset);
<span class="fc" id="L803">                    ArrayMath.negate(ref.zsol);</span>
<span class="fc" id="L804">                    project(ref.zsol, ref.pivot);</span>
                }
                break;
            }
<span class="fc" id="L808">            diagonalScaling(n, emat, v, gv, r);</span>

            /* Compute linear step length */
<span class="fc" id="L811">            double alpha = rz / vgv;</span>

            /* Compute current solution and related vectors */
<span class="fc" id="L814">            ArrayMath.axPlusY(alpha, v, ref.zsol);</span>
<span class="fc" id="L815">            ArrayMath.axPlusY(-alpha, gv, r);</span>

            /* Test for convergence */
<span class="fc" id="L818">            double gtp = ArrayMath.dotProduct(ref.zsol, g);</span>
<span class="fc" id="L819">            double pr = ArrayMath.dotProduct(r, ref.zsol);</span>
<span class="fc" id="L820">            double qnew = (gtp + pr) * 0.5;</span>
<span class="fc" id="L821">            double qtest = (k + 1) * (1.0 - qold / qnew);</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">            if (qtest &lt;= 0.5) {</span>
<span class="fc" id="L823">                break;</span>
            }

            /* Perform cautionary test */
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">            if (gtp &gt; 0.0) {</span>
                /* Truncate algorithm in case of an emergency */
<span class="nc" id="L829">                ArrayMath.axPlusY(-alpha, v, ref.zsol);</span>
<span class="nc" id="L830">                break;</span>
            }

<span class="fc" id="L833">            qold = qnew;</span>
<span class="fc" id="L834">            rzold = rz;</span>
        }

        /* Terminate algorithm */
        /* Store (or restore) diagonal preconditioning */
<span class="fc" id="L839">        ArrayMath.copy(emat, ref.diagb);</span>
<span class="fc" id="L840">    }</span>

    /**
     * Update the preconditioning matrix based on a diagonal version of the bfgs quasi-newton
     * update.
     */
    public void diagonalScaling(int n, double[] e, double[] v, double[] gv,
            double[] r) {
<span class="fc" id="L848">        double vr = 1.0 / ArrayMath.dotProduct(v, r);</span>
<span class="fc" id="L849">        double vgv = 1.0 / ArrayMath.dotProduct(v, gv);</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L851">            e[i] += -r[i] * r[i] * vr + gv[i] * gv[i] * vgv;</span>
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">            if (e[i] &lt;= 1e-6) {</span>
<span class="nc" id="L853">                e[i] = 1.0;</span>
            }
        }
<span class="fc" id="L856">    }</span>

    /**
     * Returns the length of the initial step to be taken along the vector p in the next linear
     * search.
     */
    public double initialStep(double fnew, double fmin, double gtp, double smax) {
<span class="fc" id="L863">        double d = Math.abs(fnew - fmin);</span>
<span class="fc" id="L864">        double alpha = 1.0;</span>
<span class="pc bpc" id="L865" title="1 of 4 branches missed.">        if (d * 2.0 &lt;= -(gtp) &amp;&amp; d &gt;= DBL_EPSILON) {</span>
<span class="fc" id="L866">            alpha = d * -2.0 / gtp;</span>
        }
<span class="fc bfc" id="L868" title="All 2 branches covered.">        if (alpha &gt;= smax) {</span>
<span class="fc" id="L869">            alpha = smax;</span>
        }

<span class="fc" id="L872">        return alpha;</span>
    }

    /**
     * Hessian vector product through finite differences
     */
    public void hessianTimesVector(double[] v, double[] gv, int n, double[] x,
            double[] g, double[] xscale, double[] xoffset,
            double fscale, double accuracy, double xnorm, double[] low,
            double[] up) {
<span class="fc" id="L882">        double[] xv = new double[n];</span>

<span class="fc" id="L884">        double delta = accuracy * (xnorm + 1.0);</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L886">            xv[i] = x[i] + delta * v[i];</span>
        }

<span class="fc" id="L889">        unscalex(xv, xscale, xoffset);</span>
<span class="fc" id="L890">        ArrayMath.clip(xv, low, up);</span>
<span class="fc" id="L891">        functionEvaluator.evaluate(xv, gv);</span>

<span class="fc" id="L893">        scaleg(gv, xscale, fscale);</span>

<span class="fc" id="L895">        double dinv = 1.0 / delta;</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L897">            gv[i] = (gv[i] - g[i]) * dinv;</span>
        }

<span class="fc" id="L900">        projectConstants(n, gv, xscale);</span>
<span class="fc" id="L901">    }</span>

    /**
     * This routine acts as a preconditioning step for the linear conjugate-gradient routine. It is
     * also the method of computing the search direction from the gradient for the non-linear
     * conjugate-gradient code. It represents a two-step self-scaled bfgs formula.
     */
    public void msolve(double[] g, double[] y, int n,
            double[] sk, double[] yk, double[] diagb, double[] sr,
            double[] yr, boolean upd1, double yksk, double yrsr,
            boolean lreset) {
<span class="fc bfc" id="L912" title="All 2 branches covered.">        if (upd1) {</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L914">                y[i] = g[i] / diagb[i];</span>
            }
<span class="fc" id="L916">            return;</span>
        }

<span class="fc" id="L919">        double gsk = ArrayMath.dotProduct(g, sk);</span>
<span class="fc" id="L920">        double[] hg = new double[n];</span>
<span class="fc" id="L921">        double[] hyr = new double[n];</span>
<span class="fc" id="L922">        double[] hyk = new double[n];</span>

        /* Compute gh and hy where h is the inverse of the diagonals */
<span class="fc bfc" id="L925" title="All 2 branches covered.">        if (lreset) {</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L927">                double rdiagb = 1.0 / diagb[i];</span>
<span class="fc" id="L928">                hg[i] = g[i] * rdiagb;</span>
<span class="fc" id="L929">                hyk[i] = yk[i] * rdiagb;</span>
            }
<span class="fc" id="L931">            double ykhyk = ArrayMath.dotProduct(yk, hyk);</span>
<span class="fc" id="L932">            double ghyk = ArrayMath.dotProduct(g, hyk);</span>
<span class="fc" id="L933">            ssbfgs(n, 1.0, sk, hg, hyk, yksk, ykhyk, gsk, ghyk, y);</span>
<span class="fc" id="L934">        } else {</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L936">                double rdiagb = 1.0 / diagb[i];</span>
<span class="fc" id="L937">                hg[i] = g[i] * rdiagb;</span>
<span class="fc" id="L938">                hyk[i] = yk[i] * rdiagb;</span>
<span class="fc" id="L939">                hyr[i] = yr[i] * rdiagb;</span>
            }
<span class="fc" id="L941">            double gsr = ArrayMath.dotProduct(g, sr);</span>
<span class="fc" id="L942">            double ghyr = ArrayMath.dotProduct(g, hyr);</span>
<span class="fc" id="L943">            double yrhyr = ArrayMath.dotProduct(yr, hyr);</span>
<span class="fc" id="L944">            ssbfgs(n, 1.0, sr, hg, hyr, yrsr, yrhyr, gsr, ghyr, hg);</span>
<span class="fc" id="L945">            double yksr = ArrayMath.dotProduct(yk, sr);</span>
<span class="fc" id="L946">            double ykhyr = ArrayMath.dotProduct(yk, hyr);</span>
<span class="fc" id="L947">            ssbfgs(n, 1.0, sr, hyk, hyr, yrsr, yrhyr, yksr, ykhyr, hyk);</span>
<span class="fc" id="L948">            double ykhyk = ArrayMath.dotProduct(hyk, yk);</span>
<span class="fc" id="L949">            double ghyk = ArrayMath.dotProduct(hyk, g);</span>
<span class="fc" id="L950">            ssbfgs(n, 1.0, sk, hg, hyk, yksk, ykhyk, gsk, ghyk, y);</span>
        }
<span class="fc" id="L952">    }</span>

    /**
     * Self-scaled BFGS
     */
    public void ssbfgs(int n, double gamma, double[] sj, double[] hjv,
            double[] hjyj, double yjsj, double yjhyj, double vsj, double vhyj,
            double[] hjp1v) {
        double beta, delta;
<span class="pc bpc" id="L961" title="1 of 2 branches missed.">        if (yjsj == 0.0) {</span>
<span class="nc" id="L962">            delta = 0.0;</span>
<span class="nc" id="L963">            beta = 0.0;</span>
        } else {
<span class="fc" id="L965">            delta = (gamma * yjhyj / yjsj + 1.0) * vsj / yjsj</span>
                    - gamma * vhyj / yjsj;
<span class="fc" id="L967">            beta = -gamma * vsj / yjsj;</span>
        }

<span class="fc bfc" id="L970" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L971">            hjp1v[i] = gamma * hjv[i] + delta * sj[i] + beta * hjyj[i];</span>
        }
<span class="fc" id="L973">    }</span>

    /**
     * Initialize the preconditioner
     */
    public void initPreconditioner(double[] diagb, double[] emat, int n,
            boolean lreset, double yksk, double yrsr, double[] sk, double[] yk,
            double[] sr, double[] yr, boolean upd1) {
<span class="fc bfc" id="L981" title="All 2 branches covered.">        if (upd1) {</span>
<span class="fc" id="L982">            ArrayMath.copy(diagb, emat);</span>
<span class="fc" id="L983">            return;</span>
        }

<span class="fc" id="L986">        double[] bsk = new double[n];</span>

<span class="fc bfc" id="L988" title="All 2 branches covered.">        if (lreset) {</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L990">                bsk[i] = diagb[i] * sk[i];</span>
            }
<span class="fc" id="L992">            double sds = ArrayMath.dotProduct(sk, bsk);</span>
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">            if (yksk == 0.0) {</span>
<span class="nc" id="L994">                yksk = 1.0;</span>
            }
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">            if (sds == 0.0) {</span>
<span class="nc" id="L997">                sds = 1.0;</span>
            }
<span class="fc bfc" id="L999" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1000">                double td = diagb[i];</span>
<span class="fc" id="L1001">                emat[i] = td - td * td * sk[i] * sk[i] / sds</span>
                        + yk[i] * yk[i] / yksk;
            }
<span class="fc" id="L1004">        } else {</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1006">                bsk[i] = diagb[i] * sr[i];</span>
            }
<span class="fc" id="L1008">            double sds = ArrayMath.dotProduct(sr, bsk);</span>
<span class="fc" id="L1009">            double srds = ArrayMath.dotProduct(sk, bsk);</span>
<span class="fc" id="L1010">            double yrsk = ArrayMath.dotProduct(yr, sk);</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">            if (yrsr == 0.0) {</span>
<span class="nc" id="L1012">                yrsr = 1.0;</span>
            }
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">            if (sds == 0.0) {</span>
<span class="nc" id="L1015">                sds = 1.0;</span>
            }
<span class="fc bfc" id="L1017" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1018">                double td = diagb[i];</span>
<span class="fc" id="L1019">                bsk[i] = td * sk[i] - bsk[i] * srds / sds + yr[i] * yrsk / yrsr;</span>
<span class="fc" id="L1020">                emat[i] = td - td * td * sr[i] * sr[i] / sds + yr[i] * yr[i] / yrsr;</span>
            }
<span class="fc" id="L1022">            sds = ArrayMath.dotProduct(sk, bsk);</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">            if (yksk == 0.0) {</span>
<span class="nc" id="L1024">                yksk = 1.0;</span>
            }
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">            if (sds == 0.0) {</span>
<span class="nc" id="L1027">                sds = 1.0;</span>
            }
<span class="fc bfc" id="L1029" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1030">                emat[i] -= bsk[i] * bsk[i] / sds + yk[i] * yk[i] / yksk;</span>
            }
        }
<span class="fc" id="L1033">    }</span>

<span class="pc" id="L1035">    class LinearSearchResult {</span>
        private final double alpha;
        private final double[] x;
        private final double f;
        private final double[] g;
        
<span class="fc" id="L1041">        public LinearSearchResult(double alpha, double[] x, double f, double[] g) {</span>
<span class="fc" id="L1042">            this.alpha = alpha;</span>
<span class="fc" id="L1043">            this.x = x;</span>
<span class="fc" id="L1044">            this.f = f;</span>
<span class="fc" id="L1045">            this.g = g;</span>
<span class="fc" id="L1046">        }</span>
        
        public double alpha() {
<span class="fc" id="L1049">            return alpha;</span>
        }
        
        public double[] x() {
<span class="fc" id="L1053">            return x;</span>
        }
        
        public double f() {
<span class="fc" id="L1057">            return f;</span>
        }

        public double[] g() {
<span class="fc" id="L1061">            return g;</span>
        }
    }

    
    /**
     * Line search algorithm of gill and murray
     */
    public LinearSearchResult linearSearch(double[] low,
            double[] up, double[] xscale, double[] xoffset, double fscale,
            int[] pivot, double eta, double ftol, double xBound, double[] p,
            double[] x, double f, double alpha, double gfull[]) {
<span class="fc" id="L1073">        final int MAX_ITERATIONS = 64;</span>
<span class="nc" id="L1074"></span>
<span class="fc" id="L1075">        double[] temp = new double[x.length];</span>
<span class="pc" id="L1076">        double[] tempgfull = new double[x.length];</span>
<span class="fc" id="L1077">        double[] newgfull = new double[x.length];</span>

<span class="pc" id="L1079">        ArrayMath.copy(gfull, temp);</span>
<span class="fc" id="L1080">        scaleg(temp, xscale, fscale);</span>
<span class="fc" id="L1081">        double initGu = ArrayMath.dotProduct(temp, p);</span>

<span class="fc" id="L1083">        ArrayMath.copy(x, temp);</span>
<span class="fc" id="L1084">        project(temp, pivot);</span>
<span class="pc" id="L1085">        double xnorm = ArrayMath.euclidianNorm(temp);</span>

<span class="nc" id="L1087">        // Absolute and relative tolerances for the linear search</span>
<span class="fc" id="L1088">        double rteps = Math.sqrt(DBL_EPSILON);</span>
<span class="fc" id="L1089">        double pe = ArrayMath.euclidianNorm(p) + DBL_EPSILON;</span>
<span class="fc" id="L1090">        double reltol = rteps * (xnorm + 1.0) / pe;</span>
<span class="fc" id="L1091">        double abstol = -DBL_EPSILON * (1.0 + Math.abs(f)) / (initGu - DBL_EPSILON);</span>
<span class="nc" id="L1092"></span>
<span class="nc" id="L1093">        // Smallest allowable spacing between points in the linear search</span>
<span class="fc" id="L1094">        double tnytol = DBL_EPSILON * (xnorm + 1.0) / pe;</span>
<span class="nc" id="L1095"></span>
<span class="pc" id="L1096">        double rtsmll = DBL_EPSILON;</span>
<span class="pc" id="L1097">        double big = 1.0 / (DBL_EPSILON * DBL_EPSILON);</span>
<span class="fc" id="L1098">        int itcnt = 0;</span>
<span class="nc" id="L1099"></span>
<span class="nc" id="L1100">        // Estimated relative precision in f(x)</span>
<span class="pc" id="L1101">        double fpresn = ftol;</span>

<span class="fc" id="L1103">        GetPointCubic getPointCubic = new GetPointCubic(reltol, abstol, tnytol, eta, 1e-4, xBound, alpha, f, initGu);</span>
<span class="nc" id="L1104"></span>
<span class="pc" id="L1105">        boolean requiresFurtherEvaluation = true;</span>
<span class="pc bfc" id="L1106" title="All 2 branches covered.">        while (requiresFurtherEvaluation) {</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">            if (itcnt == MAX_ITERATIONS) {</span>
<span class="nc" id="L1108">                throw new MinimizationError(&quot;Linear search failed. Max iterations reached&quot;);</span>
            }
<span class="fc" id="L1110">            itcnt++;</span>
<span class="nc" id="L1111"></span>
<span class="fc" id="L1112">            double ualpha = getPointCubic.xmin() + getPointCubic.u();</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; i++) {</span>
<span class="pc" id="L1114">                temp[i] = x[i] + ualpha * p[i];</span>
            }
<span class="nc" id="L1116"></span>
<span class="nc" id="L1117">            // Function evaluation</span>
<span class="fc" id="L1118">            unscalex(temp, xscale, xoffset);</span>
<span class="fc" id="L1119">            ArrayMath.clip(temp, low, up);</span>
<span class="pc" id="L1120">            double fu = functionEvaluator.evaluate(temp, tempgfull) * fscale;</span>
<span class="nc" id="L1121"></span>
<span class="fc" id="L1122">            ArrayMath.copy(tempgfull, temp);</span>
<span class="pc" id="L1123">            scaleg(temp, xscale, fscale);</span>
<span class="pc" id="L1124">            double gu = ArrayMath.dotProduct(temp, p);</span>
<span class="nc" id="L1125"></span>
<span class="fc" id="L1126">            requiresFurtherEvaluation = getPointCubic.iterate(big, rtsmll, tnytol, fpresn, fu, gu);</span>
<span class="nc" id="L1127"></span>
<span class="nc" id="L1128">            // New best point</span>
<span class="pc bfc" id="L1129" title="All 2 branches covered.">            if (getPointCubic.xmin() == ualpha) {</span>
<span class="pc" id="L1130">                ArrayMath.copy(tempgfull, newgfull);</span>
<span class="nc" id="L1131">            }</span>
<span class="pc" id="L1132">        } </span>
<span class="nc" id="L1133"></span>
<span class="pc" id="L1134">        double[] newX = new double[x.length];</span>
<span class="fc" id="L1135">        ArrayMath.copy(x, newX);</span>
<span class="fc" id="L1136">        ArrayMath.axPlusY(getPointCubic.xmin(), p, newX);</span>
<span class="fc" id="L1137">        return new LinearSearchResult(getPointCubic.xmin(), newX, getPointCubic.fmin(), newgfull);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>