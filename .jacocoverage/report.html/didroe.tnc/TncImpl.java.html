<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TncImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Tnc&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">didroe.tnc</a> &gt; <span class="el_source">TncImpl.java</span></div><h1>TncImpl.java</h1><pre class="source lang-java linenums">/*
 * ORIGINAL SCIPY LICENSE HEADER:
 * Copyright (c) 2002-2005, Jean-Sebastien Roy (js@jeannot.org)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * &quot;Software&quot;), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * This software is an implementation of TNBC, a truncated newton minimization
 * package originally developed by Stephen G. Nash in Fortran.
 *
 * The original source code can be found at :
 * http://iris.gmu.edu/~snash/nash/software/software.html
 *
 * Copyright for the original TNBC fortran routines:
 *
 *   TRUNCATED-NEWTON METHOD:  SUBROUTINES
 *     WRITTEN BY:  STEPHEN G. NASH
 *           SCHOOL OF INFORMATION TECHNOLOGY &amp; ENGINEERING
 *           GEORGE MASON UNIVERSITY
 *           FAIRFAX, VA 22030
 */

package didroe.tnc;

import java.text.Normalizer;
import java.util.EnumSet;
import java.util.Iterator;

/**
 *
 * @author Did
 */
<span class="fc" id="L51">public class TncImpl {</span>

    /**
     * Verbosity level
     */
<span class="pc" id="L56">    public enum tnc_message {</span>

        /**
         * No messages
         */
<span class="fc" id="L61">        TNC_MSG_NONE,</span>
        /**
         * One line per iteration
         */
<span class="fc" id="L65">        TNC_MSG_ITER,</span>
        /**
         * Informational messages
         */
<span class="fc" id="L69">        TNC_MSG_INFO,</span>
        /**
         * Exit reasons
         */
<span class="fc" id="L73">        TNC_MSG_EXIT;</span>

        /**
         * @return Set of all messages
         */
        public static EnumSet&lt;tnc_message&gt; allMessages() {
<span class="fc" id="L79">            EnumSet&lt;tnc_message&gt; result = EnumSet.of(TNC_MSG_ITER, TNC_MSG_INFO,</span>
                    TNC_MSG_EXIT);
<span class="fc" id="L81">            return result;</span>
        }
    }

    /**
     * Possible return values for tnc
     */
<span class="pc" id="L88">    public enum tnc_rc {</span>

        /**
         * Invalid parameters (n&amp;lt;0)
         */
<span class="fc" id="L93">        TNC_EINVAL(&quot;Invalid parameters (n&lt;0)&quot;),</span>
        /**
         * Infeasible (low bound &amp;gt; up bound)
         */
<span class="fc" id="L97">        TNC_INFEASIBLE(&quot;Infeasible (low bound &gt; up bound)&quot;),</span>
        /**
         * Local minima reach (|pg| ~= 0)
         */
<span class="fc" id="L101">        TNC_LOCALMINIMUM(&quot;Local minima reach (|pg| ~= 0)&quot;),</span>
        /**
         * Converged (|f_n-f_(n-1)| ~= 0)
         */
<span class="fc" id="L105">        TNC_FCONVERGED(&quot;Converged (|f_n-f_(n-1)| ~= 0)&quot;),</span>
        /**
         * Converged (|x_n-x_(n-1)| ~= 0)
         */
<span class="fc" id="L109">        TNC_XCONVERGED(&quot;Converged (|x_n-x_(n-1)| ~= 0)&quot;),</span>
        /**
         * Max. number of function evaluations reach
         */
<span class="fc" id="L113">        TNC_MAXFUN(&quot;Maximum number of function evaluations reached&quot;),</span>
        /**
         * Linear search failed
         */
<span class="fc" id="L117">        TNC_LSFAIL(&quot;Linear search failed&quot;),</span>
        /**
         * All lower bounds are equal to the upper bounds
         */
<span class="fc" id="L121">        TNC_CONSTANT(&quot;All lower bounds are equal to the upper bounds&quot;),</span>
        /**
         * Unable to progress
         */
<span class="fc" id="L125">        TNC_NOPROGRESS(&quot;Unable to progress&quot;),</span>
        /**
         * User requested end of minization
         */
<span class="fc" id="L129">        TNC_USERABORT(&quot;User requested end of minimization&quot;);</span>

        private String message;

        public String getMessage() {
<span class="fc" id="L134">            return message;</span>
        }

<span class="fc" id="L137">        private tnc_rc(String message) {</span>
<span class="fc" id="L138">            this.message = message;</span>
<span class="fc" id="L139">        }</span>
    }

    /**
     * A callback function accepting x as input parameter along with the state
     * pointer.
     */
    public interface TncCallback {

        public void tnc_callback(double[] x);
    }

    /**
     * getptc return codes
     */
<span class="pc" id="L154">    public enum getptc_rc {</span>

        /**
         * Suitable point found
         */
<span class="fc" id="L159">        GETPTC_OK,</span>
        /**
         * Function evaluation required
         */
<span class="fc" id="L163">        GETPTC_EVAL,</span>
        /**
         * Bad input values
         */
<span class="fc" id="L167">        GETPTC_EINVAL,</span>
        /**
         * No suitable point found
         */
<span class="fc" id="L171">        GETPTC_FAIL;</span>
    }

    /**
     * linearSearch return codes
     */
<span class="pc" id="L177">    public enum ls_rc {</span>

        /**
         * Suitable point found
         */
<span class="fc" id="L182">        LS_OK,</span>
        /**
         * Max. number of function evaluations reach
         */
<span class="fc" id="L186">        LS_MAXFUN,</span>
        /**
         * No suitable point found
         */
<span class="fc" id="L190">        LS_FAIL,</span>
        /**
         * User requested end of minimization
         */
<span class="fc" id="L194">        LS_USERABORT,</span>
        /**
         * Memory allocation failed
         */
<span class="fc" id="L198">        LS_ENOMEM;</span>
    }

<span class="fc" id="L201">    public static final double DBL_EPSILON = Math.ulp(1.0);</span>

    /*
     * tnc : minimize a function with variables subject to bounds, using
     *       gradient information.
     *
     * n         : number of variables (must be &gt;= 0)
     * x         : on input, initial estimate ; on output, the solution
     * f         : on output, the function value at the solution
     * g         : on output, the gradient value at the solution
     *             g should be an allocated vector of size n or NULL,
     *             in which case the gradient value is not returned.
     * function  : the function to minimize (see tnc_function)
     * state     : used by function (see tnc_function)
     * low, up   : the bounds
     *             set low[i] to Double.NEGATIVE_INFINITY to remove the lower bound
     *             set up[i] to Double.POSITIVE_INFINITY to remove the upper bound
     *             if low == NULL, the lower bounds are removed.
     *             if up == NULL, the upper bounds are removed.
     * scale     : scaling factors to apply to each variable
     *             if NULL, the factors are up-low for interval bounded variables
     *             and 1+|x] for the others.
     * offset    : constant to substract to each variable
     *             if NULL, the constant are (up+low)/2 for interval bounded
     *             variables and x for the others.
     * messages  : see the tnc_message enum
     * maxCGit   : max. number of hessian*vector evaluation per main iteration
     *             if maxCGit == 0, the direction chosen is -gradient
     *             if maxCGit &lt; 0, maxCGit is set to max(1,min(50,n/2))
     * maxnfeval : max. number of function evaluation
     * eta       : severity of the line search. if &lt; 0 or &gt; 1, set to 0.25
     * stepmx    : maximum step for the line search. may be increased during call
     *             if too small, will be set to 10.0
     * accuracy  : relative precision for finite difference calculations
     *             if &lt;= machine_precision, set to sqrt(machine_precision)
     * fmin      : minimum function value estimate
     * ftol      : precision goal for the value of f in the stoping criterion
     *             if ftol &lt; 0.0, ftol is set to accuracy
     * xtol      : precision goal for the value of x in the stopping criterion
     *             (after applying x scaling factors)
     *             if xtol &lt; 0.0, xtol is set to sqrt(machine_precision)
     * pgtol     : precision goal for the value of the projected gradient in the
     *             stopping criterion (after applying x scaling factors)
     *             if pgtol &lt; 0.0, pgtol is set to 1e-2 * sqrt(accuracy)
     *             setting it to 0.0 is not recommended
     * rescale   : f scaling factor (in log10) used to trigger f value rescaling
     *             if 0, rescale at each iteration
     *             if a big value, never rescale
     *             if &lt; 0, rescale is set to 1.3
     * nfeval    : on output, the number of function evaluations.
     *             ignored if nfeval==NULL.
     *
     * The tnc function returns a code defined in the tnc_rc enum.
     * On output, x, f and g may be very slightly out of sync because of scaling.
     *
     * This routine solves the optimization problem
     *
     *   minimize   f(x)
     *     x
     *   subject to   low &lt;= x &lt;= up
     *
     * where x is a vector of n real variables. The method used is
     * a truncated-newton algorithm (see &quot;newton-type minimization via
     * the lanczos method&quot; by s.g. nash (siam j. numer. anal. 21 (1984),
     * pp. 770-778).  this algorithm finds a local minimum of f(x). It does
     * not assume that the function f is convex (and so cannot guarantee a
     * global solution), but does assume that the function is bounded below.
     * it can solve problems having any number of variables, but it is
     * especially useful when the number of variables (n) is large.    
     */

    public tnc_rc tnc(int n, double[] x, double[] g, TncFunction function,
            double[] low, double[] up, double[] scale,
            double[] offset, EnumSet&lt;tnc_message&gt; messages, int maxCGit, int maxnfeval,
            double eta, double stepmx, double accuracy, double fmin,
            double ftol, double xtol, double pgtol, double rescale,
            TncCallback callback, TncRef ref) {
        /*int rc, frc, i, nc, nfeval_local, free_low = false,
         free_up = false, free_g = false;
         double *xscale = NULL, fscale, rteps, *xoffset = NULL;*/

<span class="fc" id="L282">        ref.nfeval = 0;</span>
        tnc_rc rc;

        cleanup:
        {
            /* Check for errors in the input parameters */
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            if (n == 0) {</span>
<span class="nc" id="L289">                rc = tnc_rc.TNC_CONSTANT;</span>
<span class="nc" id="L290">                break cleanup;</span>
            }

<span class="pc bpc" id="L293" title="1 of 2 branches missed.">            if (n &lt; 0) {</span>
<span class="nc" id="L294">                rc = tnc_rc.TNC_EINVAL;</span>
<span class="nc" id="L295">                break cleanup;</span>
            }

            /* Check bounds arrays */
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">            if (low == null) {</span>
<span class="nc" id="L300">                low = new double[n];</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L302">                    low[i] = Double.NEGATIVE_INFINITY;</span>
                }
            }

<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (up == null) {</span>
<span class="fc" id="L307">                up = new double[n];</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L309">                    up[i] = Double.POSITIVE_INFINITY;</span>
                }
            }

            /* Coherency check */
<span class="fc bfc" id="L314" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                if (low[i] &gt; up[i]) {</span>
<span class="nc" id="L316">                    rc = tnc_rc.TNC_INFEASIBLE;</span>
<span class="nc" id="L317">                    break cleanup;</span>
                }
            }

            /* Coerce x into bounds */
<span class="fc" id="L322">            ArrayMath.clip(x, low, up);</span>

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">            if (maxnfeval &lt; 1) {</span>
<span class="nc" id="L325">                rc = tnc_rc.TNC_MAXFUN;</span>
<span class="nc" id="L326">                break cleanup;</span>
            }

            /* Allocate g if necessary */
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (g == null) {</span>
<span class="nc" id="L331">                g = new double[n];</span>
            }

            /* Initial function evaluation */
<span class="fc" id="L335">            ref.f = function.evaluate(x, g);</span>
<span class="fc" id="L336">            ref.nfeval++;</span>

            /* Constant problem ? */
<span class="fc" id="L339">            int nc = 0;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L341" title="4 of 6 branches missed.">                if ((low[i] == up[i]) || (scale != null &amp;&amp; scale[i] == 0.0)) {</span>
<span class="nc" id="L342">                    nc++;</span>
                }
            }

<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            if (nc == n) {</span>
<span class="nc" id="L347">                rc = tnc_rc.TNC_CONSTANT;</span>
<span class="nc" id="L348">                break cleanup;</span>
            }

            /* Scaling parameters */
<span class="fc" id="L352">            double[] xscale = new double[n];</span>
<span class="fc" id="L353">            double[] xoffset = new double[n];</span>
<span class="fc" id="L354">            double fscale = 1.0;</span>

<span class="fc bfc" id="L356" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">                if (scale != null) {</span>
<span class="nc" id="L358">                    xscale[i] = Math.abs(scale[i]);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                    if (xscale[i] == 0.0) {</span>
<span class="nc" id="L360">                        xoffset[i] = low[i] = up[i] = x[i];</span>
                    }
<span class="fc bfc" id="L362" title="All 4 branches covered.">                } else if (low[i] != Double.NEGATIVE_INFINITY &amp;&amp; up[i] != Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L363">                    xscale[i] = up[i] - low[i];</span>
<span class="fc" id="L364">                    xoffset[i] = (up[i] + low[i]) * 0.5;</span>
                } else {
<span class="fc" id="L366">                    xscale[i] = 1.0 + Math.abs(x[i]);</span>
<span class="fc" id="L367">                    xoffset[i] = x[i];</span>
                }
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">                if (offset != null) {</span>
<span class="nc" id="L370">                    xoffset[i] = offset[i];</span>
                }
            }

            /* Default values for parameters */
<span class="fc" id="L375">            double rteps = Math.sqrt(DBL_EPSILON);</span>

<span class="pc bpc" id="L377" title="1 of 2 branches missed.">            if (stepmx &lt; rteps * 10.0) {</span>
<span class="fc" id="L378">                stepmx = 1.0e1;</span>
            }
<span class="pc bpc" id="L380" title="3 of 4 branches missed.">            if (eta &lt; 0.0 || eta &gt;= 1.0) {</span>
<span class="fc" id="L381">                eta = 0.25;</span>
            }
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">            if (rescale &lt; 0) {</span>
<span class="fc" id="L384">                rescale = 1.3;</span>
            }
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (maxCGit &lt; 0) {          /* maxCGit == 0 is valid */</span>

<span class="fc" id="L388">                maxCGit = n / 2;</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">                if (maxCGit &lt; 1) {</span>
<span class="nc" id="L390">                    maxCGit = 1;</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                } else if (maxCGit &gt; 50) {</span>
<span class="nc" id="L392">                    maxCGit = 50;</span>
                }
            }
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">            if (maxCGit &gt; n) {</span>
<span class="nc" id="L396">                maxCGit = n;</span>
            }
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if (accuracy &lt;= DBL_EPSILON) {</span>
<span class="fc" id="L399">                accuracy = rteps;</span>
            }
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if (ftol &lt; 0.0) {</span>
<span class="fc" id="L402">                ftol = accuracy;</span>
            }
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">            if (pgtol &lt; 0.0) {</span>
<span class="fc" id="L405">                pgtol = 1e-2 * Math.sqrt(accuracy);</span>
            }
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">            if (xtol &lt; 0.0) {</span>
<span class="fc" id="L408">                xtol = rteps;</span>
            }

            /* Optimisation */
<span class="fc" id="L412">            tnc_minimizeRef tmpMinRef = new tnc_minimizeRef();</span>
<span class="fc" id="L413">            tmpMinRef.f = ref.f;</span>
<span class="fc" id="L414">            tmpMinRef.fscale = fscale;</span>
<span class="fc" id="L415">            tmpMinRef.nfeval = ref.nfeval;</span>
<span class="fc" id="L416">            tmpMinRef.niter = ref.niter;</span>
<span class="fc" id="L417">            rc = tnc_minimize(n, x, g, function, xscale, xoffset, low, up,</span>
                    messages, maxCGit, maxnfeval, eta, stepmx,
                    accuracy, fmin, ftol, xtol, pgtol, rescale,
                    callback, tmpMinRef);
<span class="fc" id="L421">            ref.f = tmpMinRef.f;</span>
<span class="fc" id="L422">            fscale = tmpMinRef.fscale;</span>
<span class="fc" id="L423">            ref.nfeval = tmpMinRef.nfeval;</span>
<span class="fc" id="L424">            ref.niter = tmpMinRef.niter;</span>
        }
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        if (messages.contains(tnc_message.TNC_MSG_EXIT)) {</span>
<span class="fc" id="L427">            System.err.format(&quot;tnc: %s\n&quot;, rc.getMessage());</span>
        }

<span class="fc" id="L430">        return rc;</span>
    }


    /**
     * Unscale x
     */
    public void unscalex(int n, double[] x, double[] xscale, double xoffset[]) {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L439">            x[i] = x[i] * xscale[i] + xoffset[i];</span>
        }
<span class="fc" id="L441">    }</span>

    /**
     * Scale x
     */
    public void scalex(int n, double[] x, double[] xscale, double[] xoffset) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">            if (xscale[i] &gt; 0.0) {</span>
<span class="fc" id="L449">                x[i] = (x[i] - xoffset[i]) / xscale[i];</span>
            }
        }
<span class="fc" id="L452">    }</span>

    /**
     * Scale g
     */
    public void scaleg(int n, double[] g, double[] xscale, double fscale) {
<span class="fc bfc" id="L458" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L459">            g[i] *= xscale[i] * fscale;</span>
        }
<span class="fc" id="L461">    }</span>

    /**
     * Calculate the pivot vector
     */
    public void setConstraints(int n, double[] x, int[] pivot, double[] xscale,
            double[] xoffset, double[] low, double[] up) {
<span class="fc bfc" id="L468" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
            /* tolerances should be better ajusted */
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">            if (xscale[i] == 0.0) {</span>
<span class="nc" id="L471">                pivot[i] = 2;</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">            } else if (low[i] != Double.NEGATIVE_INFINITY</span>
                    &amp;&amp; (x[i] * xscale[i] + xoffset[i] - low[i]
<span class="fc bfc" id="L474" title="All 2 branches covered.">                    &lt;= DBL_EPSILON * 10.0 * (Math.abs(low[i]) + 1.0))) {</span>
<span class="fc" id="L475">                pivot[i] = -1;</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">            } else if (up[i] != Double.POSITIVE_INFINITY</span>
                    &amp;&amp; (x[i] * xscale[i] + xoffset[i] - up[i]
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                    &gt;= DBL_EPSILON * 10.0 * (Math.abs(up[i]) + 1.0))) {</span>
<span class="nc" id="L479">                pivot[i] = 1;</span>
            } else {
<span class="fc" id="L481">                pivot[i] = 0;</span>
            }
        }
<span class="fc" id="L484">    }</span>

<span class="fc" id="L486">    public class tnc_minimizeRef {</span>

        public double f;
        public double fscale;
        public int nfeval;
        public int niter;
    }

    /**
     * This routine is a bounds-constrained truncated-newton method. the
     * truncated-newton method is preconditioned by a limited-memory
     * quasi-newton method (this preconditioning strategy is developed in this
     * routine) with a further diagonal scaling (see routine diagonalscaling).
     */
    public tnc_rc tnc_minimize(int n, double[] x, double[] gfull,
            TncFunction function, double[] xscale, double[] xoffset,
            double[] low, double[] up, EnumSet&lt;tnc_message&gt; messages,
            int maxCGit, int maxnfeval, double eta, double stepmx,
            double accuracy, double fmin, double ftol, double xtol,
            double pgtol, double rescale, TncCallback callback, tnc_minimizeRef ref) {
        /*double fLastReset, difnew, epsred, oldgtp, difold, oldf, xnorm, newscale,
         gnorm, ustpmax, fLastConstraint, spe, yrsr, yksk,
         *temp = NULL
         , *sk = NULL
         , *yk = NULL
         , *diagb = NULL
         , *sr = NULL
         ,
         *yr = NULL
         , *oldg = NULL
         , *pk = NULL
         , *g = NULL;*/
<span class="fc" id="L518">        double alpha = 0.0;         /* Default unused value */</span>

        /*int i, icycle, oldnfeval, *pivot = NULL, frc;
         logical lreset, newcon, upd1, remcon;
         tnc_rc rc = TNC_ENOMEM;     /* Default error */
<span class="fc" id="L523">        ref.niter = 0;</span>

        /* Allocate temporary vectors */
<span class="fc" id="L526">        double[] oldg = new double[n];</span>
<span class="fc" id="L527">        double[] g = new double[n];</span>
<span class="fc" id="L528">        double[] temp = new double[n];</span>
<span class="fc" id="L529">        double[] diagb = new double[n];</span>
<span class="fc" id="L530">        double[] pk = new double[n];</span>
<span class="fc" id="L531">        double[] sk = new double[n];</span>
<span class="fc" id="L532">        double[] yk = new double[n];</span>
<span class="fc" id="L533">        double[] sr = new double[n];</span>
<span class="fc" id="L534">        double[] yr = new double[n];</span>
<span class="fc" id="L535">        int[] pivot = new int[n];</span>

        /* Initialize variables */
<span class="fc" id="L538">        double difnew = 0.0;</span>
<span class="fc" id="L539">        double epsred = 0.05;</span>
<span class="fc" id="L540">        boolean upd1 = true;</span>
<span class="fc" id="L541">        int icycle = n - 1;</span>
<span class="fc" id="L542">        boolean newcon = true;</span>

        /* Uneeded initialisations */
<span class="fc" id="L545">        boolean lreset = false;</span>
<span class="fc" id="L546">        double yrsr = 0.0;</span>
<span class="fc" id="L547">        double yksk = 0.0;</span>

        /* Initial scaling */
<span class="fc" id="L550">        scalex(n, x, xscale, xoffset);</span>
<span class="fc" id="L551">        ref.f *= ref.fscale;</span>

        /* initial pivot calculation */
<span class="fc" id="L554">        setConstraints(n, x, pivot, xscale, xoffset, low, up);</span>

<span class="fc" id="L556">        ArrayMath.copy(gfull, g);</span>
<span class="fc" id="L557">        scaleg(n, g, xscale, ref.fscale);</span>

        /* Test the lagrange multipliers to see if they are non-negative. */
<span class="fc bfc" id="L560" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">            if (-pivot[i] * g[i] &lt; 0.0) {</span>
<span class="fc" id="L562">                pivot[i] = 0;</span>
            }
        }

<span class="fc" id="L566">        project(n, g, pivot);</span>

        /* Set initial values to other parameters */
<span class="fc" id="L569">        double gnorm = ArrayMath.euclidianNorm(g);</span>

<span class="fc" id="L571">        double fLastConstraint = ref.f;       /* Value at last constraint */</span>

<span class="fc" id="L573">        double fLastReset = ref.f;            /* Value at last reset */</span>

<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        if (messages.contains(tnc_message.TNC_MSG_ITER)) {</span>
<span class="fc" id="L576">            System.err.format(&quot;  NIT   NF   F                       GTG\n&quot;);</span>
<span class="fc" id="L577">            printCurrentIteration(n, ref.f / ref.fscale, gfull,</span>
                    ref.niter, ref.nfeval, pivot);
        }

        /* Set the diagonal of the approximate hessian to unity. */
<span class="fc bfc" id="L582" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L583">            diagb[i] = 1.0;</span>
        }

        tnc_rc rc;
        /* Start of main iterative loop */
        while (true) {
            /* Local minimum test */
<span class="fc bfc" id="L590" title="All 2 branches covered.">            if (ArrayMath.euclidianNorm(g) &lt;= pgtol * ref.fscale) {</span>
                /* |PG| == 0.0 =&gt; local minimum */
<span class="fc" id="L592">                ArrayMath.copy(gfull, g);</span>
<span class="fc" id="L593">                project(n, g, pivot);</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                if (messages.contains(tnc_message.TNC_MSG_INFO)) {</span>
<span class="fc" id="L595">                    System.err.format(&quot;tnc: |pg| = %g -&gt; local minimum\n&quot;,</span>
<span class="fc" id="L596">                            ArrayMath.euclidianNorm(g) / ref.fscale);</span>
                }
<span class="fc" id="L598">                rc = tnc_rc.TNC_LOCALMINIMUM;</span>
<span class="fc" id="L599">                break;</span>
            }

            /* Terminate if more than maxnfeval evaluations have been made */
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">            if (ref.nfeval &gt;= maxnfeval) {</span>
<span class="nc" id="L604">                rc = tnc_rc.TNC_MAXFUN;</span>
<span class="nc" id="L605">                break;</span>
            }

            /* Rescale function if necessary */
<span class="fc" id="L609">            double newscale = ArrayMath.euclidianNorm(g);</span>
<span class="pc bpc" id="L610" title="1 of 4 branches missed.">            if ((newscale &gt; DBL_EPSILON) &amp;&amp; (Math.abs(Math.log10(newscale)) &gt; rescale)) {</span>
<span class="fc" id="L611">                newscale = 1.0 / newscale;</span>

<span class="fc" id="L613">                ref.f *= newscale;</span>
<span class="fc" id="L614">                ref.fscale *= newscale;</span>
<span class="fc" id="L615">                gnorm *= newscale;</span>
<span class="fc" id="L616">                fLastConstraint *= newscale;</span>
<span class="fc" id="L617">                fLastReset *= newscale;</span>
<span class="fc" id="L618">                difnew *= newscale;</span>

<span class="fc bfc" id="L620" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L621">                    g[i] *= newscale;</span>
                }
<span class="fc bfc" id="L623" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L624">                    diagb[i] = 1.0;</span>
                }

<span class="fc" id="L627">                upd1 = true;</span>
<span class="fc" id="L628">                icycle = n - 1;</span>
<span class="fc" id="L629">                newcon = true;</span>

<span class="pc bpc" id="L631" title="1 of 2 branches missed.">                if (messages.contains(tnc_message.TNC_MSG_INFO)) {</span>
<span class="fc" id="L632">                    System.err.format(&quot;tnc: fscale = %g\n&quot;, ref.fscale);</span>
                }
            }

<span class="fc" id="L636">            ArrayMath.copy(x, temp);</span>
<span class="fc" id="L637">            project(n, temp, pivot);</span>
<span class="fc" id="L638">            double xnorm = ArrayMath.euclidianNorm(temp);</span>
<span class="fc" id="L639">            int oldnfeval = ref.nfeval;</span>

            /* Compute the new search direction */
<span class="fc" id="L642">            tnc_directionRef tmpDirRef = new tnc_directionRef();</span>
<span class="fc" id="L643">            tmpDirRef.diagb = diagb;</span>
<span class="fc" id="L644">            tmpDirRef.nfeval = ref.nfeval;</span>
<span class="fc" id="L645">            tmpDirRef.pivot = pivot;</span>
<span class="fc" id="L646">            tmpDirRef.sk = sk;</span>
<span class="fc" id="L647">            tmpDirRef.sr = sr;</span>
<span class="fc" id="L648">            tmpDirRef.x = x;</span>
<span class="fc" id="L649">            tmpDirRef.yk = yk;</span>
<span class="fc" id="L650">            tmpDirRef.yr = yr;</span>
<span class="fc" id="L651">            tmpDirRef.zsol = pk;</span>
<span class="fc" id="L652">            tnc_rc frc = tnc_direction(g, n, maxCGit, maxnfeval, upd1, yksk, yrsr,</span>
                    lreset, function, xscale, xoffset, ref.fscale, accuracy, gnorm,
                    xnorm, low, up, tmpDirRef);
<span class="fc" id="L655">            diagb = tmpDirRef.diagb;</span>
<span class="fc" id="L656">            ref.nfeval = tmpDirRef.nfeval;</span>
<span class="fc" id="L657">            pivot = tmpDirRef.pivot;</span>
<span class="fc" id="L658">            sk = tmpDirRef.sk;</span>
<span class="fc" id="L659">            sr = tmpDirRef.sr;</span>
<span class="fc" id="L660">            x = tmpDirRef.x;</span>
<span class="fc" id="L661">            yk = tmpDirRef.yk;</span>
<span class="fc" id="L662">            yr = tmpDirRef.yr;</span>
<span class="fc" id="L663">            pk = tmpDirRef.zsol;</span>

            // TODO: This is not right
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">            if (frc != tnc_rc.TNC_LOCALMINIMUM) {</span>
<span class="nc" id="L667">                rc = tnc_rc.TNC_USERABORT;</span>
<span class="nc" id="L668">                break;</span>
            }

<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (!newcon) {</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">                if (!lreset) {</span>
                    /* Compute the accumulated step and its corresponding gradient
                     difference. */
<span class="fc" id="L675">                    ArrayMath.xPlusY(sk, sr);</span>
<span class="fc" id="L676">                    ArrayMath.xPlusY(yk, yr);</span>
<span class="fc" id="L677">                    icycle++;</span>
                } else {
                    /* Initialize the sum of all the changes */
<span class="fc" id="L680">                    ArrayMath.copy(sk, sr);</span>
<span class="fc" id="L681">                    ArrayMath.copy(yk, yr);</span>
<span class="fc" id="L682">                    fLastReset = ref.f;</span>
<span class="fc" id="L683">                    icycle = 1;</span>
                }
            }

<span class="fc" id="L687">            ArrayMath.copy(g, oldg);</span>
<span class="fc" id="L688">            double oldf = ref.f;</span>
<span class="fc" id="L689">            double oldgtp = ArrayMath.dotProduct(pk, g);</span>

            /* Maximum unconstrained step length */
<span class="fc" id="L692">            double ustpmax = stepmx / (ArrayMath.euclidianNorm(pk) + DBL_EPSILON);</span>

            /* Maximum constrained step length */
<span class="fc" id="L695">            double spe = stepMax(ustpmax, n, x, pk, pivot, low, up, xscale, xoffset);</span>

<span class="fc bfc" id="L697" title="All 2 branches covered.">            if (spe &gt; 0.0) {</span>
                /* Set the initial step length */
<span class="fc" id="L699">                alpha = initialStep(ref.f, fmin / ref.fscale, oldgtp, spe);</span>

                /* Perform the linear search */
<span class="fc" id="L702">                linearSearchRef tmpLinSRef = new linearSearchRef();</span>
<span class="fc" id="L703">                tmpLinSRef.alpha = alpha;</span>
<span class="fc" id="L704">                tmpLinSRef.f = ref.f;</span>
<span class="fc" id="L705">                tmpLinSRef.nfeval = ref.nfeval;</span>
<span class="fc" id="L706">                ls_rc lsrc = linearSearch(n, function, low, up,</span>
                        xscale, xoffset, ref.fscale, pivot,
                        eta, ftol, spe, pk, x, gfull,
                        maxnfeval, tmpLinSRef);
<span class="fc" id="L710">                alpha = tmpLinSRef.alpha;</span>
<span class="fc" id="L711">                ref.f = tmpLinSRef.f;</span>
<span class="fc" id="L712">                ref.nfeval = tmpLinSRef.nfeval;</span>

<span class="pc bpc" id="L714" title="1 of 2 branches missed.">                if (lsrc == ls_rc.LS_USERABORT) {</span>
<span class="nc" id="L715">                    rc = tnc_rc.TNC_USERABORT;</span>
<span class="nc" id="L716">                    break;</span>
                }

<span class="pc bpc" id="L719" title="1 of 2 branches missed.">                if (lsrc == ls_rc.LS_FAIL) {</span>
<span class="nc" id="L720">                    rc = tnc_rc.TNC_LSFAIL;</span>
<span class="nc" id="L721">                    break;</span>
                }

                /* If we went up to the maximum unconstrained step, increase it */
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">                if (alpha &gt;= 0.9 * ustpmax) {</span>
<span class="nc" id="L726">                    stepmx *= 1e2;</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                    if (messages.contains(tnc_message.TNC_MSG_INFO)) {</span>
<span class="nc" id="L728">                        System.err.format(&quot;tnc: stepmx = %g\n&quot;, stepmx);</span>
                    }
                }

                /* If we went up to the maximum constrained step,
                 a new constraint was encountered */
<span class="fc bfc" id="L734" title="All 2 branches covered.">                if (alpha - spe &gt;= -DBL_EPSILON * 10.0) {</span>
<span class="fc" id="L735">                    newcon = true;</span>
                } else {
                    /* Break if the linear search has failed to find a lower point */
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">                    if (lsrc != ls_rc.LS_OK) {</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                        if (lsrc == ls_rc.LS_MAXFUN) {</span>
<span class="nc" id="L740">                            rc = tnc_rc.TNC_MAXFUN;</span>
                        } else {
<span class="nc" id="L742">                            rc = tnc_rc.TNC_LSFAIL;</span>
                        }
<span class="nc" id="L744">                        break;</span>
                    }
<span class="fc" id="L746">                    newcon = false;</span>
                }
<span class="fc" id="L748">            } else {</span>
                /* Maximum constrained step == 0.0 =&gt; new constraint */
<span class="fc" id="L750">                newcon = true;</span>
            }

<span class="fc bfc" id="L753" title="All 2 branches covered.">            if (newcon) {</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">                if (!addConstraint(n, x, pk, pivot, low, up, xscale, xoffset)) {</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">                    if (ref.nfeval == oldnfeval) {</span>
<span class="nc" id="L756">                        rc = tnc_rc.TNC_NOPROGRESS;</span>
<span class="nc" id="L757">                        break;</span>
                    }
                }
<span class="fc" id="L760">                fLastConstraint = ref.f;</span>
            }

<span class="fc" id="L763">            ref.niter++;</span>

            /* Invoke the callback function */
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">            if (callback != null) {</span>
<span class="nc" id="L767">                unscalex(n, x, xscale, xoffset);</span>
<span class="nc" id="L768">                callback.tnc_callback(x);</span>
<span class="nc" id="L769">                scalex(n, x, xscale, xoffset);</span>
            }

            /* Set up parameters used in convergence and resetting tests */
<span class="fc" id="L773">            double difold = difnew;</span>
<span class="fc" id="L774">            difnew = oldf - ref.f;</span>

            /* If this is the first iteration of a new cycle, compute the
             percentage reduction factor for the resetting test */
<span class="fc bfc" id="L778" title="All 2 branches covered.">            if (icycle == 1) {</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">                if (difnew &gt; difold * 2.0) {</span>
<span class="fc" id="L780">                    epsred += epsred;</span>
                }
<span class="fc bfc" id="L782" title="All 2 branches covered.">                if (difnew &lt; difold * 0.5) {</span>
<span class="fc" id="L783">                    epsred *= 0.5;</span>
                }
            }

<span class="fc" id="L787">            ArrayMath.copy(gfull, g);</span>
<span class="fc" id="L788">            scaleg(n, g, xscale, ref.fscale);</span>

<span class="fc" id="L790">            ArrayMath.copy(g, temp);</span>
<span class="fc" id="L791">            project(n, temp, pivot);</span>
<span class="fc" id="L792">            gnorm = ArrayMath.euclidianNorm(temp);</span>

            /* Reset pivot */
<span class="fc" id="L795">            boolean remcon = removeConstraint(oldgtp, gnorm, pgtol * ref.fscale, ref.f,</span>
                    fLastConstraint, g, pivot, n);

            /* If a constraint is removed */
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">            if (remcon) {</span>
                /* Recalculate gnorm and reset fLastConstraint */
<span class="nc" id="L801">                ArrayMath.copy(g, temp);</span>
<span class="nc" id="L802">                project(n, temp, pivot);</span>
<span class="nc" id="L803">                gnorm = ArrayMath.euclidianNorm(temp);</span>
<span class="nc" id="L804">                fLastConstraint = ref.f;</span>
            }

<span class="pc bpc" id="L807" title="1 of 4 branches missed.">            if (!remcon &amp;&amp; !newcon) {</span>
                /* No constraint removed &amp; no new constraint : tests for convergence */
<span class="fc bfc" id="L809" title="All 2 branches covered.">                if (Math.abs(difnew) &lt;= ftol * ref.fscale) {</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                    if (messages.contains(tnc_message.TNC_MSG_INFO)) {</span>
<span class="fc" id="L811">                        System.err.format(&quot;tnc: |fn-fn-1] = %g -&gt; convergence\n&quot;,</span>
<span class="fc" id="L812">                                Math.abs(difnew) / ref.fscale);</span>
                    }
<span class="fc" id="L814">                    rc = tnc_rc.TNC_FCONVERGED;</span>
<span class="fc" id="L815">                    break;</span>
                }
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">                if (alpha * ArrayMath.euclidianNorm(pk) &lt;= xtol) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                    if (messages.contains(tnc_message.TNC_MSG_INFO)) {</span>
<span class="nc" id="L819">                        System.err.format(&quot;tnc: |xn-xn-1] = %g -&gt; convergence\n&quot;,</span>
<span class="nc" id="L820">                                alpha * ArrayMath.euclidianNorm(pk));</span>
                    }
<span class="nc" id="L822">                    rc = tnc_rc.TNC_XCONVERGED;</span>
<span class="nc" id="L823">                    break;</span>
                }
            }

<span class="fc" id="L827">            project(n, g, pivot);</span>

<span class="pc bpc" id="L829" title="1 of 2 branches missed.">            if (messages.contains(tnc_message.TNC_MSG_ITER)) {</span>
<span class="fc" id="L830">                printCurrentIteration(n, ref.f / ref.fscale, gfull,</span>
                        ref.niter, ref.nfeval, pivot);
            }

            /* Compute the change in the iterates and the corresponding change in the
             gradients */
<span class="fc bfc" id="L836" title="All 2 branches covered.">            if (!newcon) {</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L838">                    yk[i] = g[i] - oldg[i];</span>
<span class="fc" id="L839">                    sk[i] = alpha * pk[i];</span>
                }

                /* Set up parameters used in updating the preconditioning strategy */
<span class="fc" id="L843">                yksk = ArrayMath.dotProduct(yk, sk);</span>

<span class="pc bpc" id="L845" title="1 of 4 branches missed.">                if (icycle == (n - 1) || difnew &lt; epsred * (fLastReset - ref.f)) {</span>
<span class="fc" id="L846">                    lreset = true;</span>
                } else {
<span class="fc" id="L848">                    yrsr = ArrayMath.dotProduct(yr, sr);</span>
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">                    if (yrsr &lt;= 0.0) {</span>
<span class="nc" id="L850">                        lreset = true;</span>
                    } else {
<span class="fc" id="L852">                        lreset = false;</span>
                    }
                }
<span class="fc" id="L855">                upd1 = false;</span>
            }
<span class="fc" id="L857">        }</span>

<span class="pc bpc" id="L859" title="1 of 2 branches missed.">        if (messages.contains(tnc_message.TNC_MSG_ITER)) {</span>
<span class="fc" id="L860">            printCurrentIteration(n, ref.f / ref.fscale, gfull,</span>
                    ref.niter, ref.nfeval, pivot);
        }

        /* Unscaling */
<span class="fc" id="L865">        unscalex(n, x, xscale, xoffset);</span>
<span class="fc" id="L866">        ArrayMath.clip(x, low, up);</span>
<span class="fc" id="L867">        ref.f /= ref.fscale;</span>

<span class="fc" id="L869">        return rc;</span>
    }

    /**
     * Print the results of the current iteration
     */
    public void printCurrentIteration(int n, double f, double[] g, int niter,
            int nfeval, int[] pivot) {
<span class="fc" id="L877">        double gtg = 0.0;</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">            if (pivot[i] == 0) {</span>
<span class="fc" id="L880">                gtg += g[i] * g[i];</span>
            }
        }

<span class="fc" id="L884">        System.err.format(&quot; %4d %4d %22.15E  %15.8E\n&quot;, niter, nfeval, f, gtg);</span>
<span class="fc" id="L885">    }</span>

    /**
     * Set x[i] = 0.0 if direction i is currently constrained
     */
    public void project(int n, double[] x, int[] pivot) {
<span class="fc bfc" id="L891" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">            if (pivot[i] != 0) {</span>
<span class="fc" id="L893">                x[i] = 0.0;</span>
            }
        }
<span class="fc" id="L896">    }</span>

    /**
     * Set x[i] = 0.0 if direction i is constant
     */
    public void projectConstants(int n, double[] x, double[] xscale) {
<span class="fc bfc" id="L902" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">            if (xscale[i] == 0.0) {</span>
<span class="nc" id="L904">                x[i] = 0.0;</span>
            }
        }
<span class="fc" id="L907">    }</span>

    /**
     * Compute the maximum allowable step length
     */
    public double stepMax(double step, int n, double[] x, double[] dir,
            int[] pivot, double[] low, double[] up, double[] xscale, double[] xoffset) {
        /* Constrained maximum step */
<span class="fc bfc" id="L915" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L916" title="1 of 4 branches missed.">            if ((pivot[i] == 0) &amp;&amp; (dir[i] != 0.0)) {</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">                if (dir[i] &lt; 0.0) {</span>
<span class="fc" id="L918">                    double t = (low[i] - xoffset[i]) / xscale[i] - x[i];</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">                    if (t &gt; step * dir[i]) {</span>
<span class="fc" id="L920">                        step = t / dir[i];</span>
                    }
<span class="fc" id="L922">                } else {</span>
<span class="fc" id="L923">                    double t = (up[i] - xoffset[i]) / xscale[i] - x[i];</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">                    if (t &lt; step * dir[i]) {</span>
<span class="fc" id="L925">                        step = t / dir[i];</span>
                    }
                }
            }
        }

<span class="fc" id="L931">        return step;</span>
    }

    /**
     * Update the constraint vector pivot if a new constraint is encountered
     */
    public boolean addConstraint(int n, double[] x, double[] p, int[] pivot,
            double[] low, double[] up, double[] xscale, double[] xoffset) {
<span class="fc" id="L939">        boolean newcon = false;</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L941" title="1 of 4 branches missed.">            if ((pivot[i] == 0) &amp;&amp; (p[i] != 0.0)) {</span>
<span class="fc bfc" id="L942" title="All 4 branches covered.">                if (p[i] &lt; 0.0 &amp;&amp; low[i] != Double.NEGATIVE_INFINITY) {</span>
<span class="fc" id="L943">                    double tol = DBL_EPSILON * 10.0 * (Math.abs(low[i]) + 1.0);</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">                    if (x[i] * xscale[i] + xoffset[i] - low[i] &lt;= tol) {</span>
<span class="fc" id="L945">                        pivot[i] = -1;</span>
<span class="fc" id="L946">                        x[i] = (low[i] - xoffset[i]) / xscale[i];</span>
<span class="fc" id="L947">                        newcon = true;</span>
                    }
<span class="fc bfc" id="L949" title="All 2 branches covered.">                } else if (up[i] != Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L950">                    double tol = DBL_EPSILON * 10.0 * (Math.abs(up[i]) + 1.0);</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">                    if (up[i] - (x[i] * xscale[i] + xoffset[i]) &lt;= tol) {</span>
<span class="fc" id="L952">                        pivot[i] = 1;</span>
<span class="fc" id="L953">                        x[i] = (up[i] - xoffset[i]) / xscale[i];</span>
<span class="fc" id="L954">                        newcon = true;</span>
                    }
                }
            }
        }
<span class="fc" id="L959">        return newcon;</span>
    }

    /**
     * Check if a constraint is no more active
     */
    public boolean removeConstraint(double gtpnew, double gnorm, double pgtolfs,
            double f, double fLastConstraint, double[] g, int[] pivot, int n) {
<span class="fc bfc" id="L967" title="All 4 branches covered.">        if (((fLastConstraint - f) &lt;= (gtpnew * -0.5)) &amp;&amp; (gnorm &gt; pgtolfs)) {</span>
<span class="fc" id="L968">            return false;</span>
        }

<span class="fc" id="L971">        int imax = -1;</span>
<span class="fc" id="L972">        double cmax = 0.0;</span>

<span class="fc bfc" id="L974" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">            if (pivot[i] == 2) {</span>
<span class="nc" id="L976">                continue;</span>
            }
<span class="fc" id="L978">            double t = -pivot[i] * g[i];</span>
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">            if (t &lt; cmax) {</span>
<span class="nc" id="L980">                cmax = t;</span>
<span class="nc" id="L981">                imax = i;</span>
            }
        }

<span class="pc bpc" id="L985" title="1 of 2 branches missed.">        if (imax != -1) {</span>
<span class="nc" id="L986">            pivot[imax] = 0;</span>
<span class="nc" id="L987">            return true;</span>
        } else {
<span class="fc" id="L989">            return false;</span>
        }

        /*
         * For details, see gill, murray, and wright (1981, p. 308) and
         * fletcher (1981, p. 116). The multiplier tests (here, testing
         * the sign of the components of the gradient) may still need to
         * modified to incorporate tolerances for zero.
         */
    }

<span class="fc" id="L1000">    public class tnc_directionRef {</span>

        public double[] zsol;
        public double[] diagb;
        public double[] x;
        public int nfeval;
        public double[] sk;
        public double[] yk;
        public double[] sr;
        public double[] yr;
        public int[] pivot;
    }

    /**
     * This routine performs a preconditioned conjugate-gradient iteration in
     * order to solve the newton equations for a search direction for a
     * truncated-newton algorithm. When the value of the quadratic model is
     * sufficiently reduced, the iteration is terminated.
     */
    public tnc_rc tnc_direction(double[] g, int n, int maxCGit, int maxnfeval,
            boolean upd1, double yksk, double yrsr, boolean lreset,
            TncFunction function, double[] xscale, double[] xoffset,
            double fscale, double accuracy, double gnorm, double xnorm,
            double[] low, double[] up, tnc_directionRef ref) {
        /* No CG it. =&gt; dir = -grad */
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">        if (maxCGit == 0) {</span>
<span class="nc" id="L1026">            ArrayMath.copy(g, ref.zsol);</span>
<span class="nc" id="L1027">            ArrayMath.negate(ref.zsol);</span>
<span class="nc" id="L1028">            project(n, ref.zsol, ref.pivot);</span>
            // TODO : Not right
<span class="nc" id="L1030">            return tnc_rc.TNC_LOCALMINIMUM;</span>
        }

        /* General initialization */
<span class="fc" id="L1034">        double rhsnrm = gnorm;</span>
<span class="fc" id="L1035">        double tol = 1e-12;</span>
<span class="fc" id="L1036">        double qold = 0.0;</span>
<span class="fc" id="L1037">        double rzold = 0.0;                /* Uneeded */</span>

<span class="fc" id="L1039">        double[] r = new double[n]; /* Residual */</span>

<span class="fc" id="L1041">        double[] v = new double[n];</span>
<span class="fc" id="L1042">        double[] zk = new double[n];</span>
<span class="fc" id="L1043">        double[] emat = new double[n];   /* Diagonal preconditoning matrix */</span>

<span class="fc" id="L1045">        double[] gv = new double[n];       /* hessian times v */</span>

        /* Initialization for preconditioned conjugate-gradient algorithm */
<span class="fc" id="L1048">        initPreconditioner(ref.diagb, emat, n, lreset, yksk, yrsr, ref.sk, ref.yk, ref.sr,</span>
                ref.yr, upd1);

<span class="fc bfc" id="L1051" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1052">            r[i] = -g[i];</span>
<span class="fc" id="L1053">            v[i] = 0.0;</span>
<span class="fc" id="L1054">            ref.zsol[i] = 0.0;          /* Computed search direction */</span>

        }

        /* Main iteration */
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        for (int k = 0; k &lt; maxCGit; k++) {</span>
            /* CG iteration to solve system of equations */
<span class="fc" id="L1061">            project(n, r, ref.pivot);</span>
<span class="fc" id="L1062">            msolve(r, zk, n, ref.sk, ref.yk, ref.diagb, ref.sr, ref.yr, upd1, yksk, yrsr,</span>
                    lreset);
<span class="fc" id="L1064">            project(n, zk, ref.pivot);</span>
<span class="fc" id="L1065">            double rz = ArrayMath.dotProduct(r, zk);</span>

<span class="pc bpc" id="L1067" title="2 of 4 branches missed.">            if ((rz / rhsnrm &lt; tol) || (ref.nfeval &gt;= (maxnfeval - 1))) {</span>
                /* Truncate algorithm in case of an emergency
                 or too many function evaluations */
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                if (k == 0) {</span>
<span class="nc" id="L1071">                    ArrayMath.copy(g, ref.zsol);</span>
<span class="nc" id="L1072">                    ArrayMath.negate(ref.zsol);</span>
<span class="nc" id="L1073">                    project(n, ref.zsol, ref.pivot);</span>
                }
                break;
            }
            double beta;
<span class="fc bfc" id="L1078" title="All 2 branches covered.">            if (k == 0) {</span>
<span class="fc" id="L1079">                beta = 0.0;</span>
            } else {
<span class="fc" id="L1081">                beta = rz / rzold;</span>
            }

<span class="fc bfc" id="L1084" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1085">                v[i] = zk[i] + beta * v[i];</span>
            }

<span class="fc" id="L1088">            project(n, v, ref.pivot);</span>
<span class="fc" id="L1089">            tnc_rc frc = hessianTimesVector(v, gv, n, ref.x, g, function,</span>
                    xscale, xoffset, fscale, accuracy, xnorm,
                    low, up);
<span class="fc" id="L1092">            ref.nfeval++;</span>
            // TODO: Not right
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">            if (frc != tnc_rc.TNC_LOCALMINIMUM) {</span>
<span class="nc" id="L1095">                return frc;</span>
            }
<span class="fc" id="L1097">            project(n, gv, ref.pivot);</span>

<span class="fc" id="L1099">            double vgv = ArrayMath.dotProduct(v, gv);</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">            if (vgv / rhsnrm &lt; tol) {</span>
                /* Truncate algorithm in case of an emergency */
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">                if (k == 0) {</span>
<span class="fc" id="L1103">                    msolve(g, ref.zsol, n, ref.sk, ref.yk, ref.diagb, ref.sr, ref.yr, upd1, yksk,</span>
                            yrsr, lreset);
<span class="fc" id="L1105">                    ArrayMath.negate(ref.zsol);</span>
<span class="fc" id="L1106">                    project(n, ref.zsol, ref.pivot);</span>
                }
                break;
            }
<span class="fc" id="L1110">            diagonalScaling(n, emat, v, gv, r);</span>

            /* Compute linear step length */
<span class="fc" id="L1113">            double alpha = rz / vgv;</span>

            /* Compute current solution and related vectors */
<span class="fc" id="L1116">            ArrayMath.axPlusY(alpha, v, ref.zsol);</span>
<span class="fc" id="L1117">            ArrayMath.axPlusY(-alpha, gv, r);</span>

            /* Test for convergence */
<span class="fc" id="L1120">            double gtp = ArrayMath.dotProduct(ref.zsol, g);</span>
<span class="fc" id="L1121">            double pr = ArrayMath.dotProduct(r, ref.zsol);</span>
<span class="fc" id="L1122">            double qnew = (gtp + pr) * 0.5;</span>
<span class="fc" id="L1123">            double qtest = (k + 1) * (1.0 - qold / qnew);</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">            if (qtest &lt;= 0.5) {</span>
<span class="fc" id="L1125">                break;</span>
            }

            /* Perform cautionary test */
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">            if (gtp &gt; 0.0) {</span>
                /* Truncate algorithm in case of an emergency */
<span class="nc" id="L1131">                ArrayMath.axPlusY(-alpha, v, ref.zsol);</span>
<span class="nc" id="L1132">                break;</span>
            }

<span class="fc" id="L1135">            qold = qnew;</span>
<span class="fc" id="L1136">            rzold = rz;</span>
        }

        /* Terminate algorithm */
        /* Store (or restore) diagonal preconditioning */
<span class="fc" id="L1141">        ArrayMath.copy(emat, ref.diagb);</span>

        // TODO : Not right
<span class="fc" id="L1144">        return tnc_rc.TNC_LOCALMINIMUM;</span>
    }

    /**
     * Update the preconditioning matrix based on a diagonal version of the bfgs
     * quasi-newton update.
     */
    public void diagonalScaling(int n, double[] e, double[] v, double[] gv,
            double[] r) {
<span class="fc" id="L1153">        double vr = 1.0 / ArrayMath.dotProduct(v, r);</span>
<span class="fc" id="L1154">        double vgv = 1.0 / ArrayMath.dotProduct(v, gv);</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1156">            e[i] += -r[i] * r[i] * vr + gv[i] * gv[i] * vgv;</span>
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">            if (e[i] &lt;= 1e-6) {</span>
<span class="nc" id="L1158">                e[i] = 1.0;</span>
            }
        }
<span class="fc" id="L1161">    }</span>

    /**
     * Returns the length of the initial step to be taken along the vector p in
     * the next linear search.
     */
    public double initialStep(double fnew, double fmin, double gtp, double smax) {
<span class="fc" id="L1168">        double d = Math.abs(fnew - fmin);</span>
<span class="fc" id="L1169">        double alpha = 1.0;</span>
<span class="pc bpc" id="L1170" title="1 of 4 branches missed.">        if (d * 2.0 &lt;= -(gtp) &amp;&amp; d &gt;= DBL_EPSILON) {</span>
<span class="fc" id="L1171">            alpha = d * -2.0 / gtp;</span>
        }
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        if (alpha &gt;= smax) {</span>
<span class="fc" id="L1174">            alpha = smax;</span>
        }

<span class="fc" id="L1177">        return alpha;</span>
    }

    /**
     * Hessian vector product through finite differences
     */
    public tnc_rc hessianTimesVector(double[] v, double[] gv, int n, double[] x,
            double[] g, TncFunction function, double[] xscale, double[] xoffset,
            double fscale, double accuracy, double xnorm, double[] low,
            double[] up) {
<span class="fc" id="L1187">        double[] xv = new double[n];</span>

<span class="fc" id="L1189">        double delta = accuracy * (xnorm + 1.0);</span>
<span class="fc bfc" id="L1190" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1191">            xv[i] = x[i] + delta * v[i];</span>
        }

<span class="fc" id="L1194">        unscalex(n, xv, xscale, xoffset);</span>
<span class="fc" id="L1195">        ArrayMath.clip(xv, low, up);</span>
<span class="fc" id="L1196">        double f = function.evaluate(xv, gv);</span>

<span class="fc" id="L1198">        scaleg(n, gv, xscale, fscale);</span>

<span class="fc" id="L1200">        double dinv = 1.0 / delta;</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1202">            gv[i] = (gv[i] - g[i]) * dinv;</span>
        }

<span class="fc" id="L1205">        projectConstants(n, gv, xscale);</span>

<span class="fc" id="L1207">        return tnc_rc.TNC_LOCALMINIMUM;</span>
    }

    /**
     * This routine acts as a preconditioning step for the linear
     * conjugate-gradient routine. It is also the method of computing the search
     * direction from the gradient for the non-linear conjugate-gradient code.
     * It represents a two-step self-scaled bfgs formula.
     */
    public void msolve(double[] g, double[] y, int n,
            double[] sk, double[] yk, double[] diagb, double[] sr,
            double[] yr, boolean upd1, double yksk, double yrsr,
            boolean lreset) {
<span class="fc bfc" id="L1220" title="All 2 branches covered.">        if (upd1) {</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1222">                y[i] = g[i] / diagb[i];</span>
            }
<span class="fc" id="L1224">            return;</span>
        }

<span class="fc" id="L1227">        double gsk = ArrayMath.dotProduct(g, sk);</span>
<span class="fc" id="L1228">        double[] hg = new double[n];</span>
<span class="fc" id="L1229">        double[] hyr = new double[n];</span>
<span class="fc" id="L1230">        double[] hyk = new double[n];</span>

        /* Compute gh and hy where h is the inverse of the diagonals */
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        if (lreset) {</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1235">                double rdiagb = 1.0 / diagb[i];</span>
<span class="fc" id="L1236">                hg[i] = g[i] * rdiagb;</span>
<span class="fc" id="L1237">                hyk[i] = yk[i] * rdiagb;</span>
            }
<span class="fc" id="L1239">            double ykhyk = ArrayMath.dotProduct(yk, hyk);</span>
<span class="fc" id="L1240">            double ghyk = ArrayMath.dotProduct(g, hyk);</span>
<span class="fc" id="L1241">            ssbfgs(n, 1.0, sk, hg, hyk, yksk, ykhyk, gsk, ghyk, y);</span>
<span class="fc" id="L1242">        } else {</span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1244">                double rdiagb = 1.0 / diagb[i];</span>
<span class="fc" id="L1245">                hg[i] = g[i] * rdiagb;</span>
<span class="fc" id="L1246">                hyk[i] = yk[i] * rdiagb;</span>
<span class="fc" id="L1247">                hyr[i] = yr[i] * rdiagb;</span>
            }
<span class="fc" id="L1249">            double gsr = ArrayMath.dotProduct(g, sr);</span>
<span class="fc" id="L1250">            double ghyr = ArrayMath.dotProduct(g, hyr);</span>
<span class="fc" id="L1251">            double yrhyr = ArrayMath.dotProduct(yr, hyr);</span>
<span class="fc" id="L1252">            ssbfgs(n, 1.0, sr, hg, hyr, yrsr, yrhyr, gsr, ghyr, hg);</span>
<span class="fc" id="L1253">            double yksr = ArrayMath.dotProduct(yk, sr);</span>
<span class="fc" id="L1254">            double ykhyr = ArrayMath.dotProduct(yk, hyr);</span>
<span class="fc" id="L1255">            ssbfgs(n, 1.0, sr, hyk, hyr, yrsr, yrhyr, yksr, ykhyr, hyk);</span>
<span class="fc" id="L1256">            double ykhyk = ArrayMath.dotProduct(hyk, yk);</span>
<span class="fc" id="L1257">            double ghyk = ArrayMath.dotProduct(hyk, g);</span>
<span class="fc" id="L1258">            ssbfgs(n, 1.0, sk, hg, hyk, yksk, ykhyk, gsk, ghyk, y);</span>
        }
<span class="fc" id="L1260">    }</span>

    /**
     * Self-scaled BFGS
     */
    public void ssbfgs(int n, double gamma, double[] sj, double[] hjv,
            double[] hjyj, double yjsj, double yjhyj, double vsj, double vhyj,
            double[] hjp1v) {
        double beta, delta;
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">        if (yjsj == 0.0) {</span>
<span class="nc" id="L1270">            delta = 0.0;</span>
<span class="nc" id="L1271">            beta = 0.0;</span>
        } else {
<span class="fc" id="L1273">            delta = (gamma * yjhyj / yjsj + 1.0) * vsj / yjsj</span>
                    - gamma * vhyj / yjsj;
<span class="fc" id="L1275">            beta = -gamma * vsj / yjsj;</span>
        }

<span class="fc bfc" id="L1278" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1279">            hjp1v[i] = gamma * hjv[i] + delta * sj[i] + beta * hjyj[i];</span>
        }
<span class="fc" id="L1281">    }</span>

    /**
     * Initialize the preconditioner
     */
    public void initPreconditioner(double[] diagb, double[] emat, int n,
            boolean lreset, double yksk, double yrsr, double[] sk, double[] yk,
            double[] sr, double[] yr, boolean upd1) {
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        if (upd1) {</span>
<span class="fc" id="L1290">            ArrayMath.copy(diagb, emat);</span>
<span class="fc" id="L1291">            return;</span>
        }

<span class="fc" id="L1294">        double[] bsk = new double[n];</span>

<span class="fc bfc" id="L1296" title="All 2 branches covered.">        if (lreset) {</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1298">                bsk[i] = diagb[i] * sk[i];</span>
            }
<span class="fc" id="L1300">            double sds = ArrayMath.dotProduct(sk, bsk);</span>
<span class="pc bpc" id="L1301" title="1 of 2 branches missed.">            if (yksk == 0.0) {</span>
<span class="nc" id="L1302">                yksk = 1.0;</span>
            }
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">            if (sds == 0.0) {</span>
<span class="nc" id="L1305">                sds = 1.0;</span>
            }
<span class="fc bfc" id="L1307" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1308">                double td = diagb[i];</span>
<span class="fc" id="L1309">                emat[i] = td - td * td * sk[i] * sk[i] / sds</span>
                        + yk[i] * yk[i] / yksk;
            }
<span class="fc" id="L1312">        } else {</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1314">                bsk[i] = diagb[i] * sr[i];</span>
            }
<span class="fc" id="L1316">            double sds = ArrayMath.dotProduct(sr, bsk);</span>
<span class="fc" id="L1317">            double srds = ArrayMath.dotProduct(sk, bsk);</span>
<span class="fc" id="L1318">            double yrsk = ArrayMath.dotProduct(yr, sk);</span>
<span class="pc bpc" id="L1319" title="1 of 2 branches missed.">            if (yrsr == 0.0) {</span>
<span class="nc" id="L1320">                yrsr = 1.0;</span>
            }
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">            if (sds == 0.0) {</span>
<span class="nc" id="L1323">                sds = 1.0;</span>
            }
<span class="fc bfc" id="L1325" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1326">                double td = diagb[i];</span>
<span class="fc" id="L1327">                bsk[i] = td * sk[i] - bsk[i] * srds / sds + yr[i] * yrsk / yrsr;</span>
<span class="fc" id="L1328">                emat[i] = td - td * td * sr[i] * sr[i] / sds + yr[i] * yr[i] / yrsr;</span>
            }
<span class="fc" id="L1330">            sds = ArrayMath.dotProduct(sk, bsk);</span>
<span class="pc bpc" id="L1331" title="1 of 2 branches missed.">            if (yksk == 0.0) {</span>
<span class="nc" id="L1332">                yksk = 1.0;</span>
            }
<span class="pc bpc" id="L1334" title="1 of 2 branches missed.">            if (sds == 0.0) {</span>
<span class="nc" id="L1335">                sds = 1.0;</span>
            }
<span class="fc bfc" id="L1337" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1338">                emat[i] -= bsk[i] * bsk[i] / sds + yk[i] * yk[i] / yksk;</span>
            }
        }
<span class="fc" id="L1341">    }</span>

<span class="fc" id="L1343">    public class linearSearchRef {</span>

        public double f;
        public double alpha;
        public int nfeval;
    }

    /**
     * Line search algorithm of gill and murray
     */
    public ls_rc linearSearch(int n, TncFunction function, double[] low,
            double[] up, double[] xscale, double[] xoffset, double fscale,
            int[] pivot, double eta, double ftol, double xbnd, double[] p,
            double[] x, double gfull[], int maxnfeval, linearSearchRef ref) {
<span class="fc" id="L1357">        int maxlsit = 64;</span>

<span class="fc" id="L1359">        double[] temp = new double[n];</span>
<span class="fc" id="L1360">        double[] tempgfull = new double[n];</span>
<span class="fc" id="L1361">        double[] newgfull = new double[n];</span>

<span class="fc" id="L1363">        ArrayMath.copy(gfull, temp);</span>
<span class="fc" id="L1364">        scaleg(n, temp, xscale, fscale);</span>
<span class="fc" id="L1365">        double gu = ArrayMath.dotProduct(temp, p);</span>

<span class="fc" id="L1367">        ArrayMath.copy(x, temp);</span>
<span class="fc" id="L1368">        project(n, temp, pivot);</span>
<span class="fc" id="L1369">        double xnorm = ArrayMath.euclidianNorm(temp);</span>

        /* Compute the absolute and relative tolerances for the linear search */
<span class="fc" id="L1372">        double rteps = Math.sqrt(DBL_EPSILON);</span>
<span class="fc" id="L1373">        double pe = ArrayMath.euclidianNorm(p) + DBL_EPSILON;</span>
<span class="fc" id="L1374">        double reltol = rteps * (xnorm + 1.0) / pe;</span>
<span class="fc" id="L1375">        double abstol = -DBL_EPSILON * (1.0 + Math.abs(ref.f)) / (gu - DBL_EPSILON);</span>

        /* Compute the smallest allowable spacing between points in the linear
         search */
<span class="fc" id="L1379">        double tnytol = DBL_EPSILON * (xnorm + 1.0) / pe;</span>

<span class="fc" id="L1381">        double rtsmll = DBL_EPSILON;</span>
<span class="fc" id="L1382">        double big = 1.0 / (DBL_EPSILON * DBL_EPSILON);</span>
<span class="fc" id="L1383">        int itcnt = 0;</span>

        /* Set the estimated relative precision in f(x). */
<span class="fc" id="L1386">        double fpresn = ftol;</span>

<span class="fc" id="L1388">        double u = ref.alpha;</span>
<span class="fc" id="L1389">        double fu = ref.f;</span>
<span class="fc" id="L1390">        double fmin = ref.f;</span>
<span class="fc" id="L1391">        double rmu = 1e-4;</span>

        /* Setup */
<span class="fc" id="L1394">        getptcInitRef tmpPInitRef = new getptcInitRef();</span>
<span class="fc" id="L1395">        tmpPInitRef.abstol = abstol;</span>
<span class="fc" id="L1396">        tmpPInitRef.fmin = fmin;</span>
<span class="fc" id="L1397">        tmpPInitRef.fu = fu;</span>
<span class="fc" id="L1398">        tmpPInitRef.gu = gu;</span>
<span class="fc" id="L1399">        tmpPInitRef.reltol = reltol;</span>
<span class="fc" id="L1400">        tmpPInitRef.u = u;</span>
<span class="fc" id="L1401">        tmpPInitRef.xmin = ref.alpha;</span>
<span class="fc" id="L1402">        getptc_rc itest = getptcInit(tnytol, eta, rmu, xbnd, tmpPInitRef);</span>
<span class="fc" id="L1403">        double a = tmpPInitRef.a;</span>
<span class="fc" id="L1404">        abstol = tmpPInitRef.abstol;</span>
<span class="fc" id="L1405">        double b = tmpPInitRef.b;</span>
<span class="fc" id="L1406">        double b1 = tmpPInitRef.b1;</span>
<span class="fc" id="L1407">        boolean braktd = tmpPInitRef.braktd;</span>
<span class="fc" id="L1408">        double e = tmpPInitRef.e;</span>
<span class="fc" id="L1409">        double factor = tmpPInitRef.factor;</span>
<span class="fc" id="L1410">        fmin = tmpPInitRef.fmin;</span>
<span class="fc" id="L1411">        fu = tmpPInitRef.fu;</span>
<span class="fc" id="L1412">        double fw = tmpPInitRef.fw;</span>
<span class="fc" id="L1413">        double gmin = tmpPInitRef.gmin;</span>
<span class="fc" id="L1414">        double gtest1 = tmpPInitRef.gtest1;</span>
<span class="fc" id="L1415">        double gtest2 = tmpPInitRef.gtest2;</span>
<span class="fc" id="L1416">        gu = tmpPInitRef.gu;</span>
<span class="fc" id="L1417">        double gw = tmpPInitRef.gw;</span>
<span class="fc" id="L1418">        double oldf = tmpPInitRef.oldf;</span>
<span class="fc" id="L1419">        reltol = tmpPInitRef.reltol;</span>
<span class="fc" id="L1420">        double scxbnd = tmpPInitRef.scxbnd;</span>
<span class="fc" id="L1421">        double step = tmpPInitRef.step;</span>
<span class="fc" id="L1422">        double tol = tmpPInitRef.tol;</span>
<span class="fc" id="L1423">        u = tmpPInitRef.u;</span>
<span class="fc" id="L1424">        ref.alpha = tmpPInitRef.xmin;</span>
<span class="fc" id="L1425">        double xw = tmpPInitRef.xw;</span>
        
        /* If itest == GETPTC_EVAL, the algorithm requires the function value to be
         calculated */
<span class="fc bfc" id="L1429" title="All 2 branches covered.">        while (itest == getptc_rc.GETPTC_EVAL) {</span>
            /* Test for too many iterations or too many function evals */
<span class="pc bpc" id="L1431" title="2 of 4 branches missed.">            if ((++itcnt &gt; maxlsit) || (ref.nfeval &gt;= maxnfeval)) {</span>
<span class="nc" id="L1432">                break;</span>
            }

<span class="fc" id="L1435">            double ualpha = ref.alpha + u;</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1437">                temp[i] = x[i] + ualpha * p[i];</span>
            }

            /* Function evaluation */
<span class="fc" id="L1441">            unscalex(n, temp, xscale, xoffset);</span>
<span class="fc" id="L1442">            ArrayMath.clip(temp, low, up);</span>

<span class="fc" id="L1444">            fu = function.evaluate(temp, tempgfull);</span>
<span class="fc" id="L1445">            ref.nfeval++;</span>

<span class="fc" id="L1447">            fu *= fscale;</span>

<span class="fc" id="L1449">            ArrayMath.copy(tempgfull, temp);</span>
<span class="fc" id="L1450">            scaleg(n, temp, xscale, fscale);</span>
<span class="fc" id="L1451">            gu = ArrayMath.dotProduct(temp, p);</span>

<span class="fc" id="L1453">            getptcIterRef tmpPIterRef = new getptcIterRef();</span>
<span class="fc" id="L1454">            tmpPIterRef.a = a;</span>
<span class="fc" id="L1455">            tmpPIterRef.abstol = abstol;</span>
<span class="fc" id="L1456">            tmpPIterRef.b = b;</span>
<span class="fc" id="L1457">            tmpPIterRef.b1 = b1;</span>
<span class="fc" id="L1458">            tmpPIterRef.braktd = braktd;</span>
<span class="fc" id="L1459">            tmpPIterRef.e = e;</span>
<span class="fc" id="L1460">            tmpPIterRef.factor = factor;</span>
<span class="fc" id="L1461">            tmpPIterRef.fmin = fmin;</span>
<span class="fc" id="L1462">            tmpPIterRef.fu = fu;</span>
<span class="fc" id="L1463">            tmpPIterRef.fw = fw;</span>
<span class="fc" id="L1464">            tmpPIterRef.gmin = gmin;</span>
<span class="fc" id="L1465">            tmpPIterRef.gtest1 = gtest1;</span>
<span class="fc" id="L1466">            tmpPIterRef.gtest2 = gtest2;</span>
<span class="fc" id="L1467">            tmpPIterRef.gu = gu;</span>
<span class="fc" id="L1468">            tmpPIterRef.gw = gw;</span>
<span class="fc" id="L1469">            tmpPIterRef.oldf = oldf;</span>
<span class="fc" id="L1470">            tmpPIterRef.reltol = reltol;</span>
<span class="fc" id="L1471">            tmpPIterRef.scxbnd = scxbnd;</span>
<span class="fc" id="L1472">            tmpPIterRef.step = step;</span>
<span class="fc" id="L1473">            tmpPIterRef.tol = tol;</span>
<span class="fc" id="L1474">            tmpPIterRef.u = u;</span>
<span class="fc" id="L1475">            tmpPIterRef.xmin = ref.alpha;</span>
<span class="fc" id="L1476">            tmpPIterRef.xw = xw;</span>
<span class="fc" id="L1477">            itest = getptcIter(big, rtsmll, tnytol, fpresn, xbnd, tmpPIterRef);</span>
<span class="fc" id="L1478">            a = tmpPIterRef.a;</span>
<span class="fc" id="L1479">            abstol = tmpPIterRef.abstol;</span>
<span class="fc" id="L1480">            b = tmpPIterRef.b;</span>
<span class="fc" id="L1481">            b1 = tmpPIterRef.b1;</span>
<span class="fc" id="L1482">            braktd = tmpPIterRef.braktd;</span>
<span class="fc" id="L1483">            e = tmpPIterRef.e;</span>
<span class="fc" id="L1484">            factor = tmpPIterRef.factor;</span>
<span class="fc" id="L1485">            fmin = tmpPIterRef.fmin;</span>
<span class="fc" id="L1486">            fu = tmpPIterRef.fu;</span>
<span class="fc" id="L1487">            fw = tmpPIterRef.fw;</span>
<span class="fc" id="L1488">            gmin = tmpPIterRef.gmin;</span>
<span class="fc" id="L1489">            gtest1 = tmpPIterRef.gtest1;</span>
<span class="fc" id="L1490">            gtest2 = tmpPIterRef.gtest2;</span>
<span class="fc" id="L1491">            gu = tmpPIterRef.gu;</span>
<span class="fc" id="L1492">            gw = tmpPIterRef.gw;</span>
<span class="fc" id="L1493">            oldf = tmpPIterRef.oldf;</span>
<span class="fc" id="L1494">            reltol = tmpPIterRef.reltol;</span>
<span class="fc" id="L1495">            scxbnd = tmpPIterRef.scxbnd;</span>
<span class="fc" id="L1496">            step = tmpPIterRef.step;</span>
<span class="fc" id="L1497">            tol = tmpPIterRef.tol;</span>
<span class="fc" id="L1498">            u = tmpPIterRef.u;</span>
<span class="fc" id="L1499">            ref.alpha = tmpPIterRef.xmin;</span>
<span class="fc" id="L1500">            xw = tmpPIterRef.xw;</span>

            /* New best point ? */
<span class="fc bfc" id="L1503" title="All 2 branches covered.">            if (ref.alpha == ualpha) {</span>
<span class="fc" id="L1504">                ArrayMath.copy(tempgfull, newgfull);</span>
            }
<span class="fc" id="L1506">        }</span>

<span class="pc bpc" id="L1508" title="1 of 2 branches missed.">        if (itest == getptc_rc.GETPTC_OK) {</span>
            /* A successful search has been made */
<span class="fc" id="L1510">            ref.f = fmin;</span>
<span class="fc" id="L1511">            ArrayMath.axPlusY(ref.alpha, p, x);</span>
<span class="fc" id="L1512">            ArrayMath.copy(newgfull, gfull);</span>
<span class="fc" id="L1513">            return ls_rc.LS_OK;</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">        } else if (itcnt &gt; maxlsit) {</span>
            /* Too many iterations ? */
<span class="nc" id="L1516">            return ls_rc.LS_FAIL;</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">        } else if (itest != getptc_rc.GETPTC_EVAL) {</span>
            /* If itest=GETPTC_FAIL or GETPTC_EINVAL a lower point could not be found */
<span class="nc" id="L1519">            return ls_rc.LS_FAIL;</span>
        } else {
            /* Too many function evaluations */
<span class="nc" id="L1522">            return ls_rc.LS_MAXFUN;</span>
        }
    }

<span class="fc" id="L1526">    public class getptcInitRef {</span>

        public double reltol;
        public double abstol;
        public double u;
        public double fu;
        public double gu;
        public double xmin;
        public double fmin;
        public double gmin;
        public double xw;
        public double fw;
        public double gw;
        public double a;
        public double b;
        public double oldf;
        public double b1;
        public double scxbnd;
        public double e;
        public double step;
        public double factor;
        public boolean braktd;
        public double gtest1;
        public double gtest2;
        public double tol;
    }

    /**
     * getptc, an algorithm for finding a steplength, called repeatedly by
     * routines which require a step length to be computed using cubic
     * interpolation. The parameters contain information about the interval in
     * which a lower point is to be found and from this getptc computes a point
     * at which the function can be evaluated by the calling program.
     */
    public getptc_rc getptcInit(double tnytol, double eta, double rmu,
            double xbnd, getptcInitRef ref) {
        /* Check input parameters */
<span class="pc bpc" id="L1563" title="3 of 6 branches missed.">        if (ref.u &lt;= 0.0 || xbnd &lt;= tnytol || ref.gu &gt; 0.0) {</span>
<span class="nc" id="L1564">            return getptc_rc.GETPTC_EINVAL;</span>
        }
<span class="pc bpc" id="L1566" title="1 of 2 branches missed.">        if (xbnd &lt; ref.abstol) {</span>
<span class="nc" id="L1567">            ref.abstol = xbnd;</span>
        }
<span class="fc" id="L1569">        ref.tol = ref.abstol;</span>

        /* a and b define the interval of uncertainty, x and xw are points */
        /* with lowest and second lowest function values so far obtained. */
        /* initialize a,smin,xw at origin and corresponding values of */
        /* function and projection of the gradient along direction of search */
        /* at values for latest estimate at minimum. */
<span class="fc" id="L1576">        ref.a = 0.0;</span>
<span class="fc" id="L1577">        ref.xw = 0.0;</span>
<span class="fc" id="L1578">        ref.xmin = 0.0;</span>
<span class="fc" id="L1579">        ref.oldf = ref.fu;</span>
<span class="fc" id="L1580">        ref.fmin = ref.fu;</span>
<span class="fc" id="L1581">        ref.fw = ref.fu;</span>
<span class="fc" id="L1582">        ref.gw = ref.gu;</span>
<span class="fc" id="L1583">        ref.gmin = ref.gu;</span>
<span class="fc" id="L1584">        ref.step = ref.u;</span>
<span class="fc" id="L1585">        ref.factor = 5.0;</span>

        /* The minimum has not yet been bracketed. */
<span class="fc" id="L1588">        ref.braktd = false;</span>

        /* Set up xbnd as a bound on the step to be taken. (xbnd is not computed */
        /* explicitly but scxbnd is its scaled value.) Set the upper bound */
        /* on the interval of uncertainty initially to xbnd + tol(xbnd). */
<span class="fc" id="L1593">        ref.scxbnd = xbnd;</span>
<span class="fc" id="L1594">        ref.b = ref.scxbnd + ref.reltol * Math.abs(ref.scxbnd) + ref.abstol;</span>
<span class="fc" id="L1595">        ref.e = ref.b + ref.b;</span>
<span class="fc" id="L1596">        ref.b1 = ref.b;</span>

        /* Compute the constants required for the two convergence criteria. */
<span class="fc" id="L1599">        ref.gtest1 = -rmu * ref.gu;</span>
<span class="fc" id="L1600">        ref.gtest2 = -eta * ref.gu;</span>

        /* If the step is too large, replace by the scaled bound (so as to */
        /* compute the new point on the boundary). */
<span class="fc bfc" id="L1604" title="All 2 branches covered.">        if (ref.step &gt;= ref.scxbnd) {</span>
<span class="fc" id="L1605">            ref.step = ref.scxbnd;</span>
            /* Move sxbd to the left so that sbnd + tol(xbnd) = xbnd. */
<span class="fc" id="L1607">            ref.scxbnd -= (ref.reltol * Math.abs(xbnd) + ref.abstol) / (1.0 + ref.reltol);</span>
        }
<span class="fc" id="L1609">        ref.u = ref.step;</span>
<span class="pc bpc" id="L1610" title="3 of 4 branches missed.">        if (Math.abs(ref.step) &lt; ref.tol &amp;&amp; ref.step &lt; 0.0) {</span>
<span class="nc" id="L1611">            ref.u = -ref.tol;</span>
        }
<span class="pc bpc" id="L1613" title="3 of 4 branches missed.">        if (Math.abs(ref.step) &lt; ref.tol &amp;&amp; ref.step &gt;= 0.0) {</span>
<span class="nc" id="L1614">            ref.u = ref.tol;</span>
        }
<span class="fc" id="L1616">        return getptc_rc.GETPTC_EVAL;</span>
    }

<span class="fc" id="L1619">    public class getptcIterRef {</span>

        public double reltol;
        public double abstol;
        public double u;
        public double fu;
        public double gu;
        public double xmin;
        public double fmin;
        public double gmin;
        public double xw;
        public double fw;
        public double gw;
        public double a;
        public double b;
        public double oldf;
        public double b1;
        public double scxbnd;
        public double e;
        public double step;
        public double factor;
        public boolean braktd;
        public double gtest1;
        public double gtest2;
        public double tol;
    }

    public getptc_rc getptcIter(double big, double rtsmll, double tnytol,
            double fpresn, double xbnd, getptcIterRef ref) {
        ConvergenceCheck:
        {
            /* Update a,b,xw, and xmin */
<span class="fc bfc" id="L1651" title="All 2 branches covered.">            if (ref.fu &lt;= ref.fmin) {</span>
                /* If function value not increased, new point becomes next */
                /* origin and other points are scaled accordingly. */
<span class="fc" id="L1654">                double chordu = ref.oldf - (ref.xmin + ref.u) * ref.gtest1;</span>
<span class="pc bpc" id="L1655" title="1 of 2 branches missed.">                if (ref.fu &gt; chordu) {</span>
                    /* The new function value does not satisfy the sufficient decrease */
                    /* criterion. prepare to move the upper bound to this point and */
                    /* force the interpolation scheme to either bisect the interval of */
                    /* uncertainty or take the linear interpolation step which estimates */
                    /* the root of f(alpha)=chord(alpha). */

<span class="nc" id="L1662">                    double chordm = ref.oldf - ref.xmin * ref.gtest1;</span>
<span class="nc" id="L1663">                    ref.gu = -ref.gmin;</span>
<span class="nc" id="L1664">                    double denom = chordm - ref.fmin;</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">                    if (Math.abs(denom) &lt; 1e-15) {</span>
<span class="nc" id="L1666">                        denom = 1e-15;</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">                        if (chordm - ref.fmin &lt; 0.0) {</span>
<span class="nc" id="L1668">                            denom = -denom;</span>
                        }
                    }
<span class="nc bnc" id="L1671" title="All 2 branches missed.">                    if (ref.xmin != 0.0) {</span>
<span class="nc" id="L1672">                        ref.gu = ref.gmin * (chordu - ref.fu) / denom;</span>
                    }
<span class="nc" id="L1674">                    ref.fu = 0.5 * ref.u * (ref.gmin + ref.gu) + ref.fmin;</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">                    if (ref.fu &lt; ref.fmin) {</span>
<span class="nc" id="L1676">                        ref.fu = ref.fmin;</span>
                    }
<span class="nc" id="L1678">                } else {</span>
<span class="fc" id="L1679">                    ref.fw = ref.fmin;</span>
<span class="fc" id="L1680">                    ref.fmin = ref.fu;</span>
<span class="fc" id="L1681">                    ref.gw = ref.gmin;</span>
<span class="fc" id="L1682">                    ref.gmin = ref.gu;</span>
<span class="fc" id="L1683">                    ref.xmin += ref.u;</span>
<span class="fc" id="L1684">                    ref.a -= ref.u;</span>
<span class="fc" id="L1685">                    ref.b -= ref.u;</span>
<span class="fc" id="L1686">                    ref.xw = -ref.u;</span>
<span class="fc" id="L1687">                    ref.scxbnd -= ref.u;</span>
<span class="fc bfc" id="L1688" title="All 2 branches covered.">                    if (ref.gu &lt;= 0.0) {</span>
<span class="fc" id="L1689">                        ref.a = 0.0;</span>
                    } else {
<span class="fc" id="L1691">                        ref.b = 0.0;</span>
<span class="fc" id="L1692">                        ref.braktd = true;</span>
                    }
<span class="fc" id="L1694">                    ref.tol = Math.abs(ref.xmin) * ref.reltol + ref.abstol;</span>
<span class="fc" id="L1695">                    break ConvergenceCheck;</span>
                }
            }

            /* If function value increased, origin remains unchanged */
            /* but new point may now qualify as w. */
<span class="fc bfc" id="L1701" title="All 2 branches covered.">            if (ref.u &lt; 0.0) {</span>
<span class="fc" id="L1702">                ref.a = ref.u;</span>
            } else {
<span class="fc" id="L1704">                ref.b = ref.u;</span>
<span class="fc" id="L1705">                ref.braktd = true;</span>
            }
<span class="fc" id="L1707">            ref.xw = ref.u;</span>
<span class="fc" id="L1708">            ref.fw = ref.fu;</span>
<span class="fc" id="L1709">            ref.gw = ref.gu;</span>
        }

<span class="fc" id="L1712">        double twotol = ref.tol + ref.tol;</span>
<span class="fc" id="L1713">        double xmidpt = 0.5 * (ref.a + ref.b);</span>

        /* Check termination criteria */
<span class="fc bfc" id="L1716" title="All 2 branches covered.">        boolean convrg = (Math.abs(xmidpt) &lt;= twotol - 0.5 * (ref.b - ref.a))</span>
<span class="pc bpc" id="L1717" title="1 of 4 branches missed.">                || (Math.abs(ref.gmin) &lt;= ref.gtest2 &amp;&amp; ref.fmin &lt; ref.oldf</span>
<span class="pc bpc" id="L1718" title="3 of 4 branches missed.">                &amp;&amp; ((Math.abs(ref.xmin - xbnd) &gt; ref.tol) || (!ref.braktd)));</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">        if (convrg) {</span>
<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">            if (ref.xmin != 0.0) {</span>
<span class="fc" id="L1721">                return getptc_rc.GETPTC_OK;</span>
            }

            /*
             * If the function has not been reduced, check to see that the relative
             * change in f(x) is consistent with the estimate of the delta-
             * unimodality constant, tol. If the change in f(x) is larger than
             * expected, reduce the value of tol.
             */
<span class="nc bnc" id="L1730" title="All 2 branches missed.">            if (Math.abs(ref.oldf - ref.fw) &lt;= fpresn) {</span>
<span class="nc" id="L1731">                return getptc_rc.GETPTC_FAIL;</span>
            }
<span class="nc" id="L1733">            ref.tol = 0.1 * ref.tol;</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">            if (ref.tol &lt; tnytol) {</span>
<span class="nc" id="L1735">                return getptc_rc.GETPTC_FAIL;</span>
            }
<span class="nc" id="L1737">            ref.reltol = 0.1 * ref.reltol;</span>
<span class="nc" id="L1738">            ref.abstol = 0.1 * ref.abstol;</span>
<span class="nc" id="L1739">            twotol = 0.1 * twotol;</span>
        }

        /* Continue with the computation of a trial step length */
<span class="fc" id="L1743">        double r = 0.0;</span>
<span class="fc" id="L1744">        double q = 0.0;</span>
<span class="fc" id="L1745">        double s = 0.0;</span>
        MinimumFound:
        {
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">            if (Math.abs(ref.e) &gt; ref.tol) {</span>
                /* Fit cubic through xmin and xw */
<span class="fc" id="L1750">                r = 3.0 * (ref.fmin - ref.fw) / ref.xw + ref.gmin + ref.gw;</span>
<span class="fc" id="L1751">                double absr = Math.abs(r);</span>
<span class="fc" id="L1752">                q = absr;</span>
<span class="pc bpc" id="L1753" title="2 of 4 branches missed.">                if (ref.gw != 0.0 &amp;&amp; ref.gmin != 0.0) {</span>
                    /* Compute the square root of (r*r - gmin*gw) in a way
                     which avoids underflow and overflow. */
<span class="fc" id="L1756">                    double abgw = Math.abs(ref.gw);</span>
<span class="fc" id="L1757">                    double abgmin = Math.abs(ref.gmin);</span>
<span class="fc" id="L1758">                    s = Math.sqrt(abgmin) * Math.sqrt(abgw);</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">                    if (ref.gw / abgw * ref.gmin &gt; 0.0) {</span>
<span class="pc bpc" id="L1760" title="1 of 4 branches missed.">                        if (r &gt;= s || r &lt;= -s) {</span>
                            /* Compute the square root of r*r - s*s */
<span class="fc" id="L1762">                            q = Math.sqrt(Math.abs(r + s)) * Math.sqrt(Math.abs(r - s));</span>
                        } else {
<span class="fc" id="L1764">                            r = 0.0;</span>
<span class="fc" id="L1765">                            q = 0.0;</span>
<span class="fc" id="L1766">                            break MinimumFound;</span>
                        }
                    } else {
                        /* Compute the square root of r*r + s*s. */
<span class="fc" id="L1770">                        double sumsq = 1.0;</span>
<span class="fc" id="L1771">                        double p = 0.0;</span>
                        double scale;
<span class="fc bfc" id="L1773" title="All 2 branches covered.">                        if (absr &gt;= s) {</span>
                            /* There is a possibility of underflow. */
<span class="pc bpc" id="L1775" title="1 of 2 branches missed.">                            if (absr &gt; rtsmll) {</span>
<span class="fc" id="L1776">                                p = absr * rtsmll;</span>
                            }
<span class="pc bpc" id="L1778" title="1 of 2 branches missed.">                            if (s &gt;= p) {</span>
<span class="fc" id="L1779">                                double value = s / absr;</span>
<span class="fc" id="L1780">                                sumsq = 1.0 + value * value;</span>
                            }
<span class="fc" id="L1782">                            scale = absr;</span>
                        } else {
                            /* There is a possibility of overflow. */
<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">                            if (s &gt; rtsmll) {</span>
<span class="fc" id="L1786">                                p = s * rtsmll;</span>
                            }
<span class="pc bpc" id="L1788" title="1 of 2 branches missed.">                            if (absr &gt;= p) {</span>
<span class="fc" id="L1789">                                double value = absr / s;</span>
<span class="fc" id="L1790">                                sumsq = 1.0 + value * value;</span>
                            }
<span class="fc" id="L1792">                            scale = s;</span>
                        }
<span class="fc" id="L1794">                        sumsq = Math.sqrt(sumsq);</span>
<span class="fc" id="L1795">                        q = big;</span>
<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">                        if (scale &lt; big / sumsq) {</span>
<span class="fc" id="L1797">                            q = scale * sumsq;</span>
                        }
                    }
                }

                /* Compute the minimum of fitted cubic */
<span class="fc bfc" id="L1803" title="All 2 branches covered.">                if (ref.xw &lt; 0.0) {</span>
<span class="fc" id="L1804">                    q = -q;</span>
                }
<span class="fc" id="L1806">                s = ref.xw * (ref.gmin - r - q);</span>
<span class="fc" id="L1807">                q = ref.gw - ref.gmin + q + q;</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">                if (q &gt; 0.0) {</span>
<span class="fc" id="L1809">                    s = -s;</span>
                }
<span class="fc bfc" id="L1811" title="All 2 branches covered.">                if (q &lt;= 0.0) {</span>
<span class="fc" id="L1812">                    q = -q;</span>
                }
<span class="fc" id="L1814">                r = ref.e;</span>
<span class="fc bfc" id="L1815" title="All 4 branches covered.">                if (ref.b1 != ref.step || ref.braktd) {</span>
<span class="fc" id="L1816">                    ref.e = ref.step;</span>
                }
            }
        }

        /* Construct an artificial bound on the estimated steplength */
<span class="fc" id="L1822">        double a1 = ref.a;</span>
<span class="fc" id="L1823">        ref.b1 = ref.b;</span>
<span class="fc" id="L1824">        ref.step = xmidpt;</span>
<span class="pc bpc" id="L1825" title="2 of 10 branches missed.">        if ((!ref.braktd) || ((ref.a == 0.0 &amp;&amp; ref.xw &lt; 0.0) || (ref.b == 0.0 &amp;&amp; ref.xw &gt; 0.0))) {</span>
<span class="pc bpc" id="L1826" title="1 of 2 branches missed.">            if (ref.braktd) {</span>
                /* If the minimum is not bracketed by 0 and xw the step must lie
                 within (a1,b1). */
<span class="nc" id="L1829">                double d1 = ref.xw;</span>
<span class="nc" id="L1830">                double d2 = ref.a;</span>
<span class="nc bnc" id="L1831" title="All 2 branches missed.">                if (ref.a == 0.0) {</span>
<span class="nc" id="L1832">                    d2 = ref.b;</span>
                }
                /* This line might be : */
                /* if (*a == 0.0) d2 = *e */
<span class="nc" id="L1836">                ref.u = -d1 / d2;</span>
<span class="nc" id="L1837">                ref.step = 5.0 * d2 * (0.1 + 1.0 / ref.u) / 11.0;</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">                if (ref.u &lt; 1.0) {</span>
<span class="nc" id="L1839">                    ref.step = 0.5 * d2 * Math.sqrt(ref.u);</span>
                }
<span class="nc" id="L1841">            } else {</span>
<span class="fc" id="L1842">                ref.step = -ref.factor * ref.xw;</span>
<span class="fc bfc" id="L1843" title="All 2 branches covered.">                if (ref.step &gt; ref.scxbnd) {</span>
<span class="fc" id="L1844">                    ref.step = ref.scxbnd;</span>
                }
<span class="fc bfc" id="L1846" title="All 2 branches covered.">                if (ref.step != ref.scxbnd) {</span>
<span class="fc" id="L1847">                    ref.factor = 5.0 * ref.factor;</span>
                }
            }
            /* If the minimum is bracketed by 0 and xw the step must lie within (a,b) */
<span class="pc bpc" id="L1851" title="1 of 2 branches missed.">            if (ref.step &lt;= 0.0) {</span>
<span class="nc" id="L1852">                a1 = ref.step;</span>
            }
<span class="pc bpc" id="L1854" title="1 of 2 branches missed.">            if (ref.step &gt; 0.0) {</span>
<span class="fc" id="L1855">                ref.b1 = ref.step;</span>
            }
        }

        /*
         * Reject the step obtained by interpolation if it lies outside the
         * required interval or it is greater than half the step obtained
         * during the last-but-one iteration.
         */
<span class="pc bpc" id="L1864" title="1 of 6 branches missed.">        if (Math.abs(s) &lt;= Math.abs(0.5 * q * r) || s &lt;= q * a1 || s &gt;= q * ref.b1) {</span>
<span class="fc" id="L1865">            ref.e = ref.b - ref.a;</span>
        } else {
            /* A cubic interpolation step */
<span class="nc" id="L1868">            ref.step = s / q;</span>

            /* The function must not be evaluated too close to a or b. */
<span class="nc bnc" id="L1871" title="All 4 branches missed.">            if (ref.step - ref.a &lt; twotol || ref.b - ref.step &lt; twotol) {</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">                if (xmidpt &lt;= 0.0) {</span>
<span class="nc" id="L1873">                    ref.step = -ref.tol;</span>
                } else {
<span class="nc" id="L1875">                    ref.step = ref.tol;</span>
                }
            }
        }

        /* If the step is too large, replace by the scaled bound (so as to */
        /* compute the new point on the boundary). */
<span class="fc bfc" id="L1882" title="All 2 branches covered.">        if (ref.step &gt;= ref.scxbnd) {</span>
<span class="fc" id="L1883">            ref.step = ref.scxbnd;</span>
            /* Move sxbd to the left so that sbnd + tol(xbnd) = xbnd. */
<span class="fc" id="L1885">            ref.scxbnd -= (ref.reltol * Math.abs(xbnd) + ref.abstol) / (1.0 + ref.reltol);</span>
        }
<span class="fc" id="L1887">        ref.u = ref.step;</span>
<span class="pc bpc" id="L1888" title="3 of 4 branches missed.">        if (Math.abs(ref.step) &lt; ref.tol &amp;&amp; ref.step &lt; 0.0) {</span>
<span class="nc" id="L1889">            ref.u = -ref.tol;</span>
        }
<span class="pc bpc" id="L1891" title="3 of 4 branches missed.">        if (Math.abs(ref.step) &lt; ref.tol &amp;&amp; ref.step &gt;= 0.0) {</span>
<span class="nc" id="L1892">            ref.u = ref.tol;</span>
        }
<span class="fc" id="L1894">        return getptc_rc.GETPTC_EVAL;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>